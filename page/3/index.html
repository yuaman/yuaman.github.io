
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="baidu-site-verification" content="LHYPl19xg9" />
<meta name="google-site-verification" content="s5HGo7JQp9QFcl2HIOHaNDUdwj3_kdgi5nPkB5bfMHs" />
  
  <title>无题</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="无题">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="无题">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="无题">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">无题</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天南地北问乾坤</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-服务框架设计与实现的原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/22/服务框架设计与实现的原理/" class="article-date">
  <time datetime="2017-07-22T02:05:54.000Z" itemprop="datePublished">2017-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/22/服务框架设计与实现的原理/">服务框架的设计与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h2 id="1-RPC概述"><a href="#1-RPC概述" class="headerlink" title="1.RPC概述"></a>1.RPC概述</h2><p>RPC(Remote Procedure Call)即远程过程调用，允许一台计算机调用另一台计算机上的程序得到结果，而代码中不需要做额外的编程，就像在本地调用一样。</p>
<p>现在互联网应用的量级越来越大，单台计算机的能力有限，需要借助可扩展的计算机集群来完成，分布式的应用可以借助RPC来完成机器之间的调用。</p>
<h2 id="2-RPC框架原理"><a href="#2-RPC框架原理" class="headerlink" title="2.RPC框架原理"></a>2.RPC框架原理</h2><p>在RPC框架中主要有三个角色：Provider、Consumer和Registry。如下图所示：</p>
<p><img src="./_image/2018-01-30-10-40-19.jpg" alt=""><br> 节点角色说明：</p>
<ul>
<li>Server: 暴露服务的服务提供方。</li>
<li>Client: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。<h2 id="3-涉及到的Java编程知识"><a href="#3-涉及到的Java编程知识" class="headerlink" title="3.涉及到的Java编程知识"></a>3.涉及到的Java编程知识</h2><h3 id="3-1-动态代理"><a href="#3-1-动态代理" class="headerlink" title="3.1 动态代理"></a>3.1 动态代理</h3>生成 client stub和server stub需要用到 <strong>Java 动态代理技术 </strong>，我们可以使用JDK原生的动态代理机制，可以使用一些开源字节码工具框架 如：CgLib、Javassist等。</li>
</ul>
<h3 id="3-2-序列化"><a href="#3-2-序列化" class="headerlink" title="3.2 序列化"></a>3.2 序列化</h3><p>为了能在网络上传输和接收 Java对象，我们需要对它进行 序列化和反序列化操作。</p>
<p>序列化：将Java对象转换成byte[]的过程，也就是编码的过程；</p>
<p>反序列化：将byte[]转换成Java对象的过程；</p>
<p>可以使用Java原生的序列化机制，但是效率非常低，推荐使用一些开源的、成熟的序列化技术，例如：protobuf、Thrift、hessian、Kryo、Msgpack</p>
<p>关于序列化工具性能比较可以参考：<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Feishay%2Fjvm-serializers" target="_blank" rel="external">jvm-serializers</a></p>
<h3 id="3-3-反射"><a href="#3-3-反射" class="headerlink" title="3.3 反射"></a>3.3 反射</h3><p>服务发布端收到调用端的请求后，根据服务唯一标识可以获得该接口的实现类信息，通过反射创建实现类实例，进行方法的调用；</p>
<h3 id="3-4-NIO"><a href="#3-4-NIO" class="headerlink" title="3.4 NIO"></a>3.4 NIO</h3><p>当前很多RPC框架都直接基于netty这一IO通信框架，比如阿里巴巴的HSF、dubbo，Hadoop Avro，推荐使用Netty 作为底层通信框架。</p>
<h3 id="3-5-服务注册中心"><a href="#3-5-服务注册中心" class="headerlink" title="3.5 服务注册中心"></a>3.5 服务注册中心</h3><p>可选技术：</p>
<p>Redis</p>
<p>Zookeeper</p>
<p>Consul</p>
<p>Etcd</p>
<h2 id="4-客户端与服务端工作原理"><a href="#4-客户端与服务端工作原理" class="headerlink" title="4. 客户端与服务端工作原理"></a>4. 客户端与服务端工作原理</h2><p>从服务调用者以及服务提供者的角度，分别说明该服务框架的基本工作原理。如下图所示： </p>
<p><img src="file:///C:\Users\WB-YTL~1\AppData\Local\Temp\msohtmlclip1\02\clip_image002.png" alt="这里写图片描述"></p>
<p>（看不清可以访问：<a href="https://www.processon.com/chart_image/58d720fbe4b03eea782c81df.png" target="_blank" rel="external">远程调用框架工作原理</a>） </p>
<p>对于服务调用者来说： </p>
<ul>
<li><p>（1）服务框架获得服务调用者提供的服务信息（服务唯一标识：接口全限定名＋版本号；方法；调用参数）； </p>
</li>
<li><p>（2）框架根据服务信息通过服务注册查找中心查找到该服务提供者的地址列表； </p>
</li>
<li><p>（3）可根据（服务、接口、方法、参数）进行路由，确定服务提供者的地址； </p>
</li>
<li><p>（4）拼装请求参数对象Request，并序列化成二进制流； </p>
</li>
<li><p>（5）与服务端建立连接，发送序列化二进制结果； </p>
</li>
<li><p>（6）得到服务端响应，反序列化，得到最终调用结果</p>
</li>
</ul>
<p>对于服务提供者来说： </p>
<ul>
<li><p>（1）发布服务，监听端口； </p>
</li>
<li><p>（2）服务发布成功后，将服务信息（服务唯一标识：接口全限定名＋版本号；服务实现类全限定名）注册到服务注册查找中心； </p>
</li>
<li><p>（3）接收客户端请求，将请求数据反序列化为Request对象； </p>
</li>
<li><p>（4）解析Request对象，根据服务标识从服务注册查找中心获取该服务信息，例如服务接口的实现类； </p>
</li>
<li><p>（5）利用反射创建类实例对象，调用方法（多采用线程池的方式）； </p>
</li>
<li><p>（6）将调用结果序列化成二进制数据； </p>
</li>
</ul>
<p>-（7）发送响应数据到客户端；</p>
<p>注意：服务发布者需要提供给服务调用者一个二方包，包中函数接口所有方法调用的参数以及返回类型类。其实这个二方包最大的用处应该体现在：让用户像本地调用一样使用服务框架完成远程调用，但是第一个版本我们先不实现这个功能，后面可以进行优化。</p>
<h2 id="5-优化及特殊场景下的处理"><a href="#5-优化及特殊场景下的处理" class="headerlink" title="5. 优化及特殊场景下的处理"></a>5. 优化及特殊场景下的处理</h2><h3 id="5-1-路由方案"><a href="#5-1-路由方案" class="headerlink" title="5.1 路由方案"></a>5.1 路由方案</h3><h3 id="5-2-1-可用服务列表"><a href="#5-2-1-可用服务列表" class="headerlink" title="5.2.1 可用服务列表"></a>5.2.1 可用服务列表</h3><p>服务注册查找中心对于调用者来说只是提供可用的服务提供者列表。出于效率考虑，实际上也并不是每次每次调用远程服务的时候都会去注册查找中心查找可用地址，而是把地址缓存在调用者本地，当有变化时服务注册查找中心主动发起通知，告诉调用者，可用的服务提供者列表发生了变化，让调用者重新发起查询动作。</p>
<p>当获取到可提供服务的地址列表后，就是选择一个地址去请求服务。</p>
<h4 id="5-2-2-路由机制"><a href="#5-2-2-路由机制" class="headerlink" title="5.2.2  路由机制"></a>5.2.2  路由机制</h4><p>这里的选择路由机制就可以参考负载均衡的实现，使用随机、轮询、权重等方式。</p>
<p>通常集群机器能力对等的情况下我们会使用随机与轮询，及其能力不对等我们会采用权重，机器能力可以根据响应时间来判断。</p>
<p>调用端对路由选择的考虑点有很多，为了考虑服务提供端集群的压力均衡，基于接口、方法、参数的路由，可以把路由选择的粒度足够小到参数的划分上。根据不同粒度划分可以将响应慢的服务调用与响应快的服务调用隔离开来。</p>
<h3 id="5-2-3-多机房场景"><a href="#5-2-3-多机房场景" class="headerlink" title="5.2.3 多机房场景"></a>5.2.3 多机房场景</h3><p>先不考虑异地的场景，只考虑同城的情况。一般来说，同城有两三个机房是很正常的，而正常情况下我们希望provider，consumer，registry在同一个机房中，节省网络资源；但也要考虑到不正常的情况如：每个机房的服务提供者处理能力不对等，同机房的服务提供者大面积瘫痪的情况；<br>综合以上情况，可以有以下两种方案选择：<br>1.利用机房网段进行路由，优先选择同机房服务，如果该机房综合处理能力不够，则扩展到其他机房<br>2.扩展物理机房为逻辑机房<br>在这里个人不建议在查询可用服务列表时就对provider根据规则进行过滤，这样会减小后续对provider集群处理能力判断的空间；建议查出全部可用列表之后根据及其能力以及可用率综合判断，进行选择；</p>
<h3 id="5-2-流量控制"><a href="#5-2-流量控制" class="headerlink" title="5.2 流量控制"></a>5.2 流量控制</h3><p>秒杀场景有流量控制的说法，rpc框架为了整体服务的可用性，也应该进行consumer与provider之间的流量控制。<br>两个方案：<br>1.根据请求目标控制，目标服务的函数的请求次数，超过次数则拒绝访问<br>2.根据来源控制，来自同一个机器的请求次数不得超过某个限定，超过则直接拒绝访问</p>
<h3 id="5-4-服务提供者的设计与实现"><a href="#5-4-服务提供者的设计与实现" class="headerlink" title="5.4 服务提供者的设计与实现"></a>5.4 服务提供者的设计与实现</h3><p>的实现、发布、部署、升级、治理</p>
<h4 id="5-4-1-服务实现"><a href="#5-4-1-服务实现" class="headerlink" title="5.4.1 服务实现"></a>5.4.1 服务实现</h4><p>服务提供端的工作线程是一个线程池，路由到provider的请求会被放到线程池中执行，工作线程有多个，根据服务以及方法签名确定调用的线程池，实现隔离，不会出现争抢资源的情况。</p>
<h4 id="5-4-2-暴露远程服务给调用者"><a href="#5-4-2-暴露远程服务给调用者" class="headerlink" title="5.4.2 暴露远程服务给调用者"></a>5.4.2 暴露远程服务给调用者</h4><p>服务端的工作有两个：<br>（1）将本地提供的服务注册到 服务注册查找中心(zookeeper)；</p>
<p>（2）根据进来的请求定位服务并执行。</p>
<p>下面给出一个服务提供端的配置示例：</p>
<p><img src="./_image/2018-01-30-11-35-20.jpg" alt=""></p>
<p>这里写图片描述</p>
<p>这个和请求调用端的bean的配置非常类似，但是也有区别：<br>（1）服务提供端使用的是ProviderBean对象，而客户端使用的是ConsumerBean对象。</p>
<p>（2）服务端指定了一个target属性，表明要具体执行服务的bean，在下面的bean中也定义了。但是ProviderBean并不执行具体的服务，只是起到调用端代码存根的作用。</p>
<p>（3）ProviderBean的职能是：服务需要注册到服务注册查找中心之后才能被服务调用者发现，所以ProviderBean需要将自己所代表的服务注册到服务注册查找中心。</p>
<p>服务的发布是按照Spring Bean注入的方式，在spring配置文件中显式声明注入一个providerBean，同时声明多个property，用这种方式非常有利于之后服务属性的扩展，通常需要配置的属性有服务名称（interfaceName），服务版本号（version），服务机器所在群组（group）;也有需要声明secret的情况；</p>
<h4 id="5-4-3-服务部署"><a href="#5-4-3-服务部署" class="headerlink" title="5.4.3 服务部署"></a>5.4.3 服务部署</h4><p>服务框架的部署有两个方式，一个是把服务框架作为应用的一个依赖包与应用一起打包；或者打成一个sar包与容器一起启动，比如将公用vm包打成一个sar包；</p>
<p>服务Jar包冲突：<br>将服务框架的类与应用自身的类各自控制在user-defined classloader级别，这样实现相互隔离。</p>
<h4 id="5-4-4-服务升级"><a href="#5-4-4-服务升级" class="headerlink" title="5.4.4 服务升级"></a>5.4.4 服务升级</h4><p>每次改动发布更新版本号，进行冒烟以及灰度发布。</p>
<h4 id="5-4-5-服务治理"><a href="#5-4-5-服务治理" class="headerlink" title="5.4.5 服务治理"></a>5.4.5 服务治理</h4><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>懂得了原理，再看dubbo和eureka的实现，太简单了。所有RPC框架的原理都是一样的，包括HSF，Dubbo等；</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/22/服务框架设计与实现的原理/" data-id="cjdd53x3e002kfdjdqujn9sj4" class="article-share-link" data-share="baidu" data-title="服务框架的设计与实现">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-Java类加载机制常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/20/Java类加载机制常见问题/" class="article-date">
  <time datetime="2017-07-20T06:43:54.000Z" itemprop="datePublished">2017-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/20/Java类加载机制常见问题/">Java类加载机制常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java类加载机制常见问题梳理<br>
        
          <p class="article-more-link">
            <a href="/2017/07/20/Java类加载机制常见问题/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/20/Java类加载机制常见问题/" data-id="cjdd53x1l000ffdjd5iup7w01" class="article-share-link" data-share="baidu" data-title="Java类加载机制常见问题">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDK探究/">JDK探究</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-读《Effecttive Java》" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/18/读《Effecttive Java》/" class="article-date">
  <time datetime="2017-07-18T02:05:54.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/读《Effecttive Java》/">读《Effecttive Java》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<h3 id="2019-09-15"><a href="#2019-09-15" class="headerlink" title="2019-09-15"></a>2019-09-15</h3><p>“读完一本《Effecttive Java》，才算是一个中级Java程序员”，这是一个前辈说的话。最近在读这本书，和其他基本书一起，还没有全部读完。</p>
<p>在第一遍看的过程当中，有很多地方看不懂。即使是在已经很熟悉的操作当中例如并发和equals，hashcode等条目中也有这种 情况。</p>
<p>作者参与了sun和google的Java设计，参与了并发包的设计，所以主要的问题在于很多他认为习以为常的概念我们并不懂。也因为翻译的问题，导致我们看很不流畅。例如有些地方讲到回收机制，只是蜻蜓点水的一提，但是如果没有对垃圾回收做过了解的会自然而然的略过去，因为不知道他说的是啥。</p>
<h3 id="2019-09-14"><a href="#2019-09-14" class="headerlink" title="2019-09-14"></a>2019-09-14</h3><p><img src="./_image/2018-01-29-18-03-05.jpg" alt=""></p>
<p><img src="./_image/2018-01-29-18-02-27.jpg" alt=""></p>
<p>原文：Java语言规范保证读或者写一个变量是原子的，除非这个变量的类型为long或double。多个线程在没有同步的情况下也是如此。</p>
<p>（刚开始看到这句话不太理解）</p>
<p>看到后来，明白了。</p>
<p>互斥：是对对象的锁定</p>
<p>同步：被锁定的对象与其他任务之间的通信效果</p>
<p>重量级锁实现了互斥还实现了同步</p>
<p>轻量级锁volatile实现了同步（可见性）并没有实现互斥（以及一定程度的有序性）</p>
<p>例如经典的volatile是否可以解决i++问题。</p>
<p>首先要明白一点，i++本身不是一个原子操作。</p>
<p>volatile的两层语义是可以保证对象的可见性以及一定程度的有序性，但不能保证操作的原子性，所以volatile的两个使用条件的终极含义就是要保证操作的原子性。</p>
<p>所以volatile在并发情况下保证不了i++的线程安全，解决不了这个问题。</p>
<p>而为什么i++不是一个原子操作呢？</p>
<p>因为它是先读取（获得i），再写入（i+1）。并发情况下如果第二个线程在第一个线程的读取和写入操作之间进行i的读取，那么就会看到同一个值，返回相同的结果，造成程序错误。（安全性失败）</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/18/读《Effecttive Java》/" data-id="cjdd53x3m0032fdjdkuhvt7sv" class="article-share-link" data-share="baidu" data-title="读《Effecttive Java》">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-分布式缓存一致性Hash算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/18/分布式缓存一致性Hash算法/" class="article-date">
  <time datetime="2017-07-18T02:05:54.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/分布式缓存一致性Hash算法/">分布式缓存一致性hash算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>当服务器不多，并且不考虑扩容的时候，可直接使用简单的路由算法，用服务器数除缓存数据KEY的hash值，余数作为服务器下标即可。</p>
<p>但是当业务发展，网站缓存服务需要扩容时就会出现问题，比如3台缓存服务器要扩容到4台，就会导致75%的数据无法命中，当100台服务器中增加一台，不命中率会到达99%（n/（n+1））,这显然是不能接受的。</p>
<p>在设计分布式缓存集群的时候，需要考虑集群的伸缩性，也就是当向集群中增加服务器的时候，要尽量减小对集群的影响，而一致性hash算法就是用来解决集群伸缩性。</p>
<p>一致性hash算法通过构造一个长度为2^32的整数环，根据节点名的hash值将缓存服务器节点放置在这个环上，然后计算要缓存的数据的key的hash值，顺时针找到最近的服务器节点，将数据放到该服务器上。</p>
<p> <img src="https://images2015.cnblogs.com/blog/1142924/201704/1142924-20170419222407649-1722046559.png" alt=""><br>有Node0,Node1,Node2三个节点，假设Node0的hash值是1024,key1的hash值是500，key1在环上顺时针查找，最近的节点就是Node0。<br>当服务器集群又开始扩容，新增了Node3节点，从三个节点扩容到了四个节点。<br><img src="https://images2015.cnblogs.com/blog/1142924/201704/1142924-20170419222955759-356675425.png" alt=""></p>
<p>Node3加到了Node2和Node1之间，除了Node2到Node3之间原本是Node1的数据无法再命中，其它的数据不受影响，3台扩容到4台可命中率高达75%，<br>而且集群越大，影响越小，100台服务器增加一台，命中率可达到99%。</p>
<p>查找不小于查找树的最小值是用的二叉查找树实现的。<br>但是这样子还是会存在一个问题，就是负载不均衡的问题，当Node3加到Node2和Node1之间时，原本会访问Node1的缓存数据有50%的概率会缓存到Node3上了，这样Node0和Node2的负载会是Node1和Node3的两倍。</p>
<p>要解决一致性hash算法带来的负载不均衡问题，可通过将每台物理服务器虚拟成一组虚拟缓存服务器，将虚拟服务器的hash值放置在hash环上，KEY在环上先找到虚拟服务器节点，然后再映射到实际的服务器上。</p>
<p> <img src="https://images2015.cnblogs.com/blog/1142924/201704/1142924-20170419225054337-11861583.png" alt=""><br>这样在Node0,1,2虚拟节点都已存在的情况下，将Node3的多个虚拟节点分散到它们中间，多个虚拟的Node3节点会影响到其它的多个虚拟节点，而不是只影响其中一个，这样将命中率不会有变化，但是负载却更加均衡了而且虚拟节点越多越均衡。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/18/分布式缓存一致性Hash算法/" data-id="cjdd53x2s001yfdjdy918lov7" class="article-share-link" data-share="baidu" data-title="分布式缓存一致性hash算法">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-分布式锁通用解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/18/分布式锁通用解决方案/" class="article-date">
  <time datetime="2017-07-18T02:05:54.000Z" itemprop="datePublished">2017-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/分布式锁通用解决方案/">分布式锁通用解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="分布式锁的解决方式："><a href="#分布式锁的解决方式：" class="headerlink" title="分布式锁的解决方式："></a>分布式锁的解决方式：</h3><h3 id="基于数据库："><a href="#基于数据库：" class="headerlink" title="基于数据库："></a>基于数据库：</h3><blockquote>
<p>   基于数据库表做乐观锁，用于分布式锁。（version）</p>
<p>   基于数据库表做悲观锁（InnoDB，for update）</p>
<p>   基于数据库表数据记录做唯一约束（表中记录方法名称）</p>
</blockquote>
<h3 id="基于缓存："><a href="#基于缓存：" class="headerlink" title="基于缓存："></a>基于缓存：</h3><blockquote>
<p> 常用方案：使用redis的setnx()用于分布式锁。（setNx，直接设置值为当前时间+超时时间，保持操作原子性）</p>
<p>使用memcached的add()方法，用于分布式锁。</p>
<p>使用Tair的put()方法，用于分布式锁。</p>
</blockquote>
<h3 id="基于Zookeeper："><a href="#基于Zookeeper：" class="headerlink" title="基于Zookeeper："></a>基于Zookeeper：</h3><blockquote>
<p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。</p>
</blockquote>
        
          <p class="article-more-link">
            <a href="/2017/07/18/分布式锁通用解决方案/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/18/分布式锁通用解决方案/" data-id="cjdd53x310029fdjdsth8cdn2" class="article-share-link" data-share="baidu" data-title="分布式锁通用解决方案">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-mongoDB常见问题整理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/15/mongoDB常见问题整理/" class="article-date">
  <time datetime="2017-07-15T09:37:31.000Z" itemprop="datePublished">2017-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/15/mongoDB常见问题整理/">mongoDB常见问题整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="多方收集整理成此篇，以后也会持续更新。"><a href="#多方收集整理成此篇，以后也会持续更新。" class="headerlink" title="多方收集整理成此篇，以后也会持续更新。"></a>多方收集整理成此篇，以后也会持续更新。</h5>
        
          <p class="article-more-link">
            <a href="/2017/07/15/mongoDB常见问题整理/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/15/mongoDB常见问题整理/" data-id="cjdd53x2c001cfdjd087gsrpm" class="article-share-link" data-share="baidu" data-title="mongoDB常见问题整理">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-Java实现动态代理与Spring的动态代理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/11/Java实现动态代理与Spring的动态代理/" class="article-date">
  <time datetime="2017-07-11T02:05:54.000Z" itemprop="datePublished">2017-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/11/Java实现动态代理与Spring的动态代理/">Java实现动态代理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>Java实现动态代理的大致步骤如下：</p>
<p>1.定义一个委托类和公共接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//公共接口</div><div class="line">public interface IHello &#123;</div><div class="line">  void sayHello();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//委托类</div><div class="line">class Hello implements IHello &#123;</div><div class="line">  public void sayHello() &#123;</div><div class="line">      System.out.println(&quot;Hello world!!&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.通过实现InvocationHandler接口来自定义自己的InvocationHandler，指定运行时将生成的代理类需要完成的具体任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//自定义InvocationHandler</div><div class="line">public class HWInvocationHandler implements InvocationHandler &#123;</div><div class="line">  // 目标对象</div><div class="line">  private Object target;</div><div class="line"></div><div class="line">  public HWInvocationHandler(Object target) &#123;</div><div class="line">      this.target = target;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public Object invoke(Object proxy, Method method, Object[] args) &gt;throws Throwable &#123;</div><div class="line">      System.out.println(&quot;------插入前置通知代码-------------&quot;);</div><div class="line">      // 执行相应的目标方法</div><div class="line">      Object rs = method.invoke(target, args);</div><div class="line">      System.out.println(&quot;------插入后置处理代码-------------&quot;);</div><div class="line">      return rs;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.生成代理对象，这个可以分为四步：<br>    （1）通过Proxy.getProxyClass获得动态代理类<br>    （2）通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)<br>    （3）通过构造函数获得代理对象并将自定义的InvocationHandler实例对象传为参数传入<br>    （4）通过代理对象调用目标方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">  public static void main(String[] args)</div><div class="line">          throws NoSuchMethodException, IllegalAccessException, &gt;InvocationTargetException, InstantiationException &#123;</div><div class="line">      // 生成Proxy的class文件</div><div class="line">      System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</div><div class="line">      // 获取动态代理类</div><div class="line">      Class&lt;?&gt; proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(), IHello.class);</div><div class="line">      // 获得代理类的构造函数，并传入参数类型InvocationHandler.class</div><div class="line">      Constructor&lt;?&gt; constructor = proxyClazz.getConstructor(InvocationHandler.class);</div><div class="line">      // 通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入</div><div class="line">      IHello iHello = (IHello) constructor.newInstance(new  HWInvocationHandler(new Hello()));</div><div class="line">      // 通过代理对象调用目标方法</div><div class="line">      iHello.sayHello();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象，其方法签名为：newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] instance, InvocationHandler h)，如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Client2 &#123;</div><div class="line">  public static void main(String[] args) throws NoSuchMethodException,IllegalAccessException, InvocationTargetException, InstantiationException &#123;</div><div class="line">         //生成$Proxy0的class文件</div><div class="line">         System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</div><div class="line">         IHello  ihello = (IHello) &gt;Proxy.newProxyInstance(IHello.class.getClassLoader(),  //加载接口的类加载器</div><div class="line">                 new Class[]&#123;IHello.class&#125;,      //一组接口</div><div class="line">                 new HWInvocationHandler(new Hello())); //自定义的&gt;InvocationHandler</div><div class="line">         ihello.sayHello();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么）</p>
<p>参考链接：<a href="https://www.jianshu.com/p/fa339e474c7a" target="_blank" rel="external">https://www.jianshu.com/p/fa339e474c7a</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/11/Java实现动态代理与Spring的动态代理/" data-id="cjdd53x1n000hfdjdavpc9c40" class="article-share-link" data-share="baidu" data-title="Java实现动态代理">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDK探究/">JDK探究</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-Sprign 动态代理机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/10/Sprign 动态代理机制/" class="article-date">
  <time datetime="2017-07-10T02:05:54.000Z" itemprop="datePublished">2017-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/10/Sprign 动态代理机制/">Sprign 动态代理机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spirng的AOP的动态代理实现机制有两种，分别是:</p>
<p><strong>1）JDK动态代理：</strong></p>
<p><strong>具体实现原理：</strong></p>
<p>1、通**过实现InvocationHandlet接口创建自己的调用处理器</p>
<p>2、通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理</p>
<p>3、通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型</p>
<p>4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入</p>
<p>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，<br>Spring通过java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</p>
<p><strong>2、CGLib动态代理</strong></p>
<p><strong>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程呢。</strong></p>
<p><strong>两者对比：</strong></p>
<p>JDK动态代理是面向接口，在创建代理实现类时比CGLib要快，创建代理速度快。</p>
<p>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败），在创建代理这一块没有JDK动态代理快，但是运行速度比JDK动态代理要快。</p>
<p><strong>使用注意：</strong></p>
<p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）</p>
<p>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</p>
<p><strong>那么如何选择的使用代理机制了？</strong></p>
<p><strong><img src="http://img.blog.csdn.net/20170222115622781" alt=""></strong></p>
<p>通过配置Spring的中<aop:config>标签来显示的指定使用动态代理机制 proxy-target-class=true表示使用CGLib代理，如果为false就是默认使用JDK动态代理</aop:config></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/10/Sprign 动态代理机制/" data-id="cjdd53x20000sfdjd07vled8b" class="article-share-link" data-share="baidu" data-title="Sprign 动态代理机制">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring探究/">Spring探究</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-mongoDB底层运作原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/05/mongoDB底层运作原理/" class="article-date">
  <time datetime="2017-07-05T09:37:31.000Z" itemprop="datePublished">2017-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/05/mongoDB底层运作原理/">mongoDB运作原理与分片实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="觉得这一篇整理比较好，主要在于通俗易懂，逻辑清晰。但是网上转载的人太多了，我实在找不到原作者了。"><a href="#觉得这一篇整理比较好，主要在于通俗易懂，逻辑清晰。但是网上转载的人太多了，我实在找不到原作者了。" class="headerlink" title="觉得这一篇整理比较好，主要在于通俗易懂，逻辑清晰。但是网上转载的人太多了，我实在找不到原作者了。"></a>觉得这一篇整理比较好，主要在于通俗易懂，逻辑清晰。但是网上转载的人太多了，我实在找不到原作者了。</h5>
        
          <p class="article-more-link">
            <a href="/2017/07/05/mongoDB底层运作原理/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/05/mongoDB底层运作原理/" data-id="cjdd53x2j001mfdjdwxdzi88s" class="article-share-link" data-share="baidu" data-title="mongoDB运作原理与分片实现">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式系统/">分布式系统</a></li></ul>

    </footer>
  </div>
  



</article>




  
    <article id="post-读曾宪杰《大型网站系统与Java中间件实践》" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/20/读曾宪杰《大型网站系统与Java中间件实践》/" class="article-date">
  <time datetime="2017-06-20T02:05:54.000Z" itemprop="datePublished">2017-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/20/读曾宪杰《大型网站系统与Java中间件实践》/">读曾宪杰《大型网站系统与Java中间件实践》</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>1.分布式系统相对集中式而言，是指多台计算机互相通过消息通信进行协作而对外提供服务；可解决大型机的伸缩性和单点等问题；</p>
<p>2.网络i/o有bio/nio，还有aio，aio是指线程拿到消息后并不自己处理或等处理结束之后再响应，而是将消息投递之后继续后面的处理，只将回调传递给被调用方，消息处理完成之后自动由被调用方完成回调，也就是异步io，java7支持aio；</p>
<p>3.分布式系统有几个难点：缺乏全局时钟（可以把时间序号获取交给单独集群来做）；面对故障的独立性（要考虑其它模块可靠与不可靠的情况）；单点故障处理（能拆分的拆分，能换集群的换集群，不能拆分到最细的做到备份以备自动恢复）；事务的挑战（两阶段提交协议，最终一致性等）；</p>
<p>4.单机应用演化过程：</p>
<p>1）单机负载告警后，数据库与应用服务器做分享；</p>
<p>2）应用服务器负载告警后应用服务器做集群，涉及负载均衡设备，涉及session问题可将session存cookie或session拷贝或统一session服务管理中心；</p>
<p>3）数据库压力变大，读写分离，涉及数据复制问题和应用对数据源的选择问题，读库前面也可再加缓存，数据实时要求不高还可采用搜索引擎作为读；</p>
<p>4）缓存除了可用来缓存数据，还可用来缓存页面，缓存一切对实时性要求不高的内容；</p>
<p>5）引入分布式存储（文件/kv）系统缓解数据库的存取；</p>
<p>6）读写分离后数据库仍有瓶颈，采用专库专用，数据库的垂直拆分；</p>
<p>7）数据库垂直拆分后再遇到数据库单机瓶颈，考虑水平拆分；此时引入数据存取中间件；</p>
<p>8）数据库问题解决后，新的挑战时采用应用拆分服务化方式；此时引入消息中间件的服务框架中间件；</p>
<p>5.Java中间件主要有三类：服务框架中间件，消息中间件和数据访问中间件；</p>
<p>6.votatile和synchronized的区别：volatile表示每次读写都直接读写主存，不会拷贝到线程存储中，也就是所有线程操作的都是同一份，这并不表示只有一个线程能同时操作；sychronized是表示加锁，保持数据的一致性；</p>
<p>7.Java的Atomics包中的类是一些支持原子性操作的类，它们的性能会有明显的提升是因为Java使用了硬件特性来支持；</p>
<p>8.CountDownLatch是等待线程调用latch.await，等待latch减少到0就能往下走了，而释放线程则使用latch.countDown来每次调用释放1；</p>
<p>9.CyclicBarrier是指所有调用barrier.await的线程都要等到其它线程都执行到这一条语句之后才往后执行，barrier还可以预设一个线程在满足条件后运行；</p>
<p>10.Exchanger是指两个线程都执行到这条语句时互换一个信号，然后各自继续执行；</p>
<p>11.Future是指获取这个结果的线程调用是异步的，代码可以先往下执行，等到要真正要使用这个返回值时如果仍未返回才会停下来，FutureTask是其实现类。</p>
<p>12.并发容器如果有合适场景尽量使用Java提供的，不要自己基于锁去实现；</p>
<p>13.动态代理，是指把类和接口，接口Handler等名称传递进去给Proxy.newProxyInstance方法来动态创建代理的方式，可在方法触发前后甚至触发时进行对应处理，这在服务调用框架之类的客户端或服务端，一些能用Bean可以让用户配置接口，从而生成代理，由代理来处理来自外部的调用，而在调用前后进行替换。</p>
<p>14.服务框架大致是这样实现的：</p>
<p>1）调用端：通过bean配置方式来配置远程服务，服务提供方地址一般通过一个配置中心来给出，动态代理在接口调用时通过服务框架的方法来获取远程对应服务提供方地址，接装请求参数等来进行序列化进行Socket直连（采用bio/nio等），得到响应结果后反序列化为对应的对象返回给上层调用方；超时等问题的处理可通过Future来实现，还可以实现多个调用之间的合并优化，即发起多个类似异步调用，在使用到它们结果时才会卡住；</p>
<p>2）服务方：通过bean配置方式来配置远程服务提供者，启动后注册到对应的配置中心，启动若干个线程（池，用来处理流控）来监听某一个端口的请求，当连接到来时调用具体实现类之前做一些返序列化工具，调用之后再进行一些序列化操作返回给远程调用者；应用本身与框架的jar包冲突问题通过ClassLoader来解决；</p>
<p>3）服务注册中心：主要用来管理注册来上的调用者和服务提供方，同时可兼具路由管理，信息查看等功能；路由可细化到类或方法，还可通过分组来把同一机房的提供者标识出来；服务升级一般是采用版本号的方式来，即先将服务升级，新老并存，老的调用方全升级后再下线老服务；</p>
<p>15.服务框架实战中的优化，即服务治理需要的内容：服务信息管理，服务质量管理评估，服务容量评估，服务依赖展示，服务分布展示，服务统计，服务报表，服务元数据等；服务管理还有服务的限流，上下线，降级，路由，服务授权管理等等；</p>
<p>16.服务框架与ESB异同，都是面向服务化，服务框架主要考虑同构系统不考虑异构，ESB会考虑不同厂商的实现；</p>
<p>17.数据库水平/垂直拆分的困难：</p>
<p>1）单机的事务机制被打破，要考虑分布式事务的控制；</p>
<p>2）一些单库操作需要到多个库中操作，表连接需要用应用方式来实现；</p>
<p>3）外键约束需要程序来保证而非数据库；</p>
<p>4）依靠单库的自增序列方式要改变；</p>
<p>18.分布式事务有两阶段提交协议，但对大型网站来说还是太复杂而且会有性能问题，比之更轻量的有Paxos协议，其核心原则是少数服务多数；一般能不引入分布式事务就不要引入，如果一定要引入也不追求强一致性而只要求最终一致性，即通过重试的方式把未完成的做完而不回滚；</p>
<p>19.大型网站一致性理论：CAP，即一致性，响应/可用性，部分出问题时仍能工作（Partition-Tolerance），这几个属性之间是互斥的，因此更多是放弃完全一致性，只追求最终一致性即可；</p>
<p>20.跨库查询且要排序是最难处理的问题，等于要将所有分库的数据查出来再运算，应该尽量避免这种情况，尤其是分页到后面数据量更在，如果数据量巨大的，可考虑使用搜索引擎；</p>
<p>21.数据访问中间件的设计一般是在jdbc/orm框架之下加一层用来处理路由，sql分析等；一般会有一堆的数据源需要处理，包括数据的划分规则（取模不易于扩展，考虑一致性哈希，有人退出时旁边的接管之，可以将一个物理结点虚出多个虚拟结点方式缓解任务过于集中的问题），而数据层需要进行如下转换：sql解析，规则处理，sql改写（在各库中表名可能不一样），数据源选择，sql执行，结果集返回合并处理这些步骤。</p>
<p>22.数据访问中间件可以在应用中以jar包方式引入，也可以考虑单独部署一个应用，业务应用只与这个应用打交道，而各种规则由这个应用来解析与执行。</p>
<p>23.读写分享等的数据同步，主要由otter来完成，基于数据库日志解析的，国际站可做到秒级延时，国内可做到ms级，阿里内部现在在做单元化，多地多活等方案，也需要这些同步技术。</p>
<p>24.平滑数据迁移其实是先全量迁移，然后再将这一过程中老库的变更记录在新库执行，这个递归过程会越来越短，当需要迁移的增量很少时，暂停对这部分数据的写操作，然后快速完成处理，切换路由到新库。</p>
<p>25.消息中间件可解耦应用之间的依赖，而且一般用业解决异步调用等实时性要求不高的问题，比如登录后发短信或是数据同步，记录日志这些。</p>
<p>26.消息投递与业务处理的一致性问题很长时候都需要保证，一些可让用户随意重复的除外，因此需要引入事务类似的方式，但分布式事务成本太高，所以一个相对折中的方案是：</p>
<p>1）发送消息给消息中间件；</p>
<p>2）消息中间件入库消息；</p>
<p>3）消息中间件返回结果；</p>
<p>4）业务操作；</p>
<p>5）发送业务操作结果给消息中间件；</p>
<p>6）更改存储中的消息状态；</p>
<p>这个方案只有第5第6步可能引发不一致性问题，但这种情况下消息都可以通过消息中间件的未处理消息状态来问消息发送源进行反查。</p>
<p>27.消息中间件一般有topic和queue两种，有不同的应用场景，有时候还需要级联的方式来处理。</p>
<p>28.消息发送端及发送过程的可靠性是通过本地存储+重试的方式来保证，对于失败的消息会保留下来并在消息中心恢复之后重新发送；而对于存储端则一般可采用数据库来存储消息，还可以采用双机内存的方式来加快速度，使存储只在内存中运转并两台机器之间相互备份，一旦一台挂掉则另一台落磁盘存储并接管消息。</p>
<p>29.消息处理端一般都需要保证消息处理操作的等幂性以防止消息投递出错有重复的消息产生；</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/06/20/读曾宪杰《大型网站系统与Java中间件实践》/" data-id="cjdd53x3x003jfdjd4wsq6yi6" class="article-share-link" data-share="baidu" data-title="读曾宪杰《大型网站系统与Java中间件实践》">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  



</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK探究/">JDK探究</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring探究/">Spring探究</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/个人开源项目/">个人开源项目</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式系统/">分布式系统</a><span class="tag-list-count">22</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式缓存/">分布式缓存</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作记录/">操作记录</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发方案/">高并发方案</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JDK探究/" style="font-size: 18px;">JDK探究</a> <a href="/tags/Spring探究/" style="font-size: 14px;">Spring探究</a> <a href="/tags/个人开源项目/" style="font-size: 12px;">个人开源项目</a> <a href="/tags/分布式系统/" style="font-size: 20px;">分布式系统</a> <a href="/tags/分布式缓存/" style="font-size: 12px;">分布式缓存</a> <a href="/tags/操作记录/" style="font-size: 12px;">操作记录</a> <a href="/tags/读书笔记/" style="font-size: 16px;">读书笔记</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a> <a href="/tags/高并发方案/" style="font-size: 10px;">高并发方案</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/07/软负载中心与集中配置管理/">软负载中心与集中配置管理</a>
          </li>
        
          <li>
            <a href="/2018/01/25/消息中间件的设计与实践/">消息中间件的设计与实践</a>
          </li>
        
          <li>
            <a href="/2018/01/25/消息中间件的设计与实现/">消息中间件的设计与实践</a>
          </li>
        
          <li>
            <a href="/2018/01/11/分布式系统幂等性解决方案/">分布式系统幂等性解决方案</a>
          </li>
        
          <li>
            <a href="/2017/09/19/读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地/">读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/yuaman" target="_blank">我的git同性交友主页</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  



  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 yutinglin<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>



</footer>


  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->









</div>
</body>
</html>
