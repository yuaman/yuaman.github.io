
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="baidu-site-verification" content="LHYPl19xg9" />
<meta name="google-site-verification" content="s5HGo7JQp9QFcl2HIOHaNDUdwj3_kdgi5nPkB5bfMHs" />
  
  <title>Java类加载机制原理解析 | 无题</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java类加载机制原理解析">
<meta name="keywords" content="JVM相关">
<meta property="og:type" content="article">
<meta property="og:title" content="Java类加载机制原理解析">
<meta property="og:url" content="http://yoursite.com/2017/07/25/Java类加载机制原理解析/index.html">
<meta property="og:site_name" content="无题">
<meta property="og:description" content="Java类加载机制原理解析">
<meta property="og:image" content="http://og287lnu0.bkt.clouddn.com/20140629212337234">
<meta property="og:image" content="http://og287lnu0.bkt.clouddn.com/20140629212049968">
<meta property="og:image" content="http://og287lnu0.bkt.clouddn.com/20140629211854375">
<meta property="og:updated_time" content="2017-08-30T05:43:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java类加载机制原理解析">
<meta name="twitter:description" content="Java类加载机制原理解析">
<meta name="twitter:image" content="http://og287lnu0.bkt.clouddn.com/20140629212337234">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">无题</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天南地北问乾坤</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Java类加载机制原理解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/25/Java类加载机制原理解析/" class="article-date">
  <time datetime="2017-07-25T04:19:54.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java类加载机制原理解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java类加载机制原理解析<br><a id="more"></a> </p>
<h3 id="要点整理："><a href="#要点整理：" class="headerlink" title="要点整理："></a>要点整理：</h3><h5 id="1-JVM三种预定义类加载器"><a href="#1-JVM三种预定义类加载器" class="headerlink" title="1.JVM三种预定义类加载器"></a>1.JVM三种预定义类加载器</h5><p>启动（Bootstrap）类加载器（JRE／lib下核心类库）</p>
<p>扩展（Extension）类加载器（JRE／lib／ext下类库）</p>
<p>系统（System）类加载器（classpath指定目录下的类库）</p>
<h5 id="2-三种加载器的父子关系"><a href="#2-三种加载器的父子关系" class="headerlink" title="2.三种加载器的父子关系"></a>2.三种加载器的父子关系</h5><p>委派关系：System &gt; Extension &gt; Bootstrap</p>
<p>继承关系：System &gt; Extension &gt; securityClassloader &gt; urlclassloader &gt;classloader</p>
<h5 id="3-双亲委派模型："><a href="#3-双亲委派模型：" class="headerlink" title="3.双亲委派模型："></a>3.双亲委派模型：</h5><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<h5 id="4-自定义类加载器："><a href="#4-自定义类加载器：" class="headerlink" title="4.自定义类加载器："></a>4.自定义类加载器：</h5><p>待整理</p>
<p>转载地址：<a href="http://blog.csdn.net/zhoudaxia/article/details/35824249" target="_blank" rel="external">http://blog.csdn.net/zhoudaxia/article/details/35824249</a></p>
<h2 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1 基本信息"></a>1 基本信息</h2><p>每个开发人员对Java.lang.ClassNotFoundExcetpion这个异常肯定都不陌生，这背后就涉及到了java技术体系中的类加载。Java的类加载机制是技术体系中比较核心的部分，虽然和大部分开发人员直接打交道不多，但是对其背后的机理有一定理解有助于排查程序中出现的类加载失败等技术问题，对理解java虚拟机的连接模型和java语言的动态性都有很大帮助。</p>
<h2 id="2-Java虚拟机类加载器结构简述"><a href="#2-Java虚拟机类加载器结构简述" class="headerlink" title="2 Java虚拟机类加载器结构简述"></a>2 Java虚拟机类加载器结构简述</h2><h3 id="2-1-JVM三种预定义类型类加载器"><a href="#2-1-JVM三种预定义类型类加载器" class="headerlink" title="2.1 JVM三种预定义类型类加载器"></a>2.1 JVM三种预定义类型类加载器</h3><p>　　我们首先看一下JVM预定义的三种类型类加载器，当一个 JVM启动的时候，Java缺省开始使用如下三种类型类装入器：</p>
<h4 id="启动（Bootstrap）类加载器："><a href="#启动（Bootstrap）类加载器：" class="headerlink" title="启动（Bootstrap）类加载器："></a>启动（Bootstrap）类加载器：</h4><p>　　引导类装入器是用本地代码实现的类装入器，它负责将 <java_runtime_home>/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</java_runtime_home></p>
<h4 id="扩展（Extension）类加载器："><a href="#扩展（Extension）类加载器：" class="headerlink" title="扩展（Extension）类加载器："></a>扩展（Extension）类加载器：</h4><p>扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
<h4 id="系统（System）类加载器："><a href="#系统（System）类加载器：" class="headerlink" title="系统（System）类加载器："></a>系统（System）类加载器：</h4><p>系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。</p>
<p>　　除了以上列举的三种类加载器，还有一种比较特殊的类型就是线程上下文类加载器，这个将在后面单独介绍。</p>
<h3 id="2-2-类加载双亲委派机制介绍和分析"><a href="#2-2-类加载双亲委派机制介绍和分析" class="headerlink" title="2.2 类加载双亲委派机制介绍和分析"></a>2.2 类加载双亲委派机制介绍和分析</h3><p>在这里，需要着重说明的是，JVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和扩展类加载器为例作简单分析。</p>
<p>图一 标准扩展类加载器继承层次图</p>
<p><img src="http://og287lnu0.bkt.clouddn.com/20140629212337234"></p>
<p>图二系统类加载器继承层次图</p>
<p><img src="http://og287lnu0.bkt.clouddn.com/20140629212049968"></p>
<p>通过图一和图二我们可以看出，类加载器均是继承自java.lang.ClassLoader抽象类。我们下面我们就看简要介绍一下java.lang.ClassLoader中几个最重要的方法：</p>
<pre><code>[java] view plain copy
1. //加载指定名称（包括包名）的二进制类型，供用户调用的接口  
2. public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException{ … }  
3.   
4. //加载指定名称（包括包名）的二进制类型，同时指定是否解析（但是这里的resolve参数不一定真正能达到解析的效果），供继承用  
5. protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ … }  
6.   
7. //findClass方法一般被loadClass方法调用去加载指定名称类，供继承用  
8. protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { … }  
9.   
10. //定义类型，一般在findClass方法中读取到对应字节码后调用，可以看出不可继承  
11. //（说明：JVM已经实现了对应的具体功能，解析对应的字节码，产生对应的内部数据结构放置到方法区，所以无需覆写，直接调用就可以了）  
12. protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError{ … }  
</code></pre><p>　　通过进一步分析标准扩展类加载器（sun.misc.Launcher$ExtClassLoader）和系统类加载器（sun.misc.Launcher$AppClassLoader）的代码以及其公共父类（java.net.URLClassLoader和java.security.SecureClassLoader）的代码可以看出，都没有覆写java.lang.ClassLoader中默认的加载委派规则—loadClass（…）方法。既然这样，我们就可以通过分析java.lang.ClassLoader中的loadClass（String name）方法的代码就可以分析出虚拟机默认采用的双亲委派机制到底是什么模样：
　　</p>
<pre><code>1. public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {  
2.     return loadClass(name, false);  
3. }  
4.   
5. protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)  
6.         throws ClassNotFoundException {  
7.   
8.     // 首先判断该类型是否已经被加载  
9.     Class c = findLoadedClass(name);  
10.     if (c == null) {  
11.         //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载  
12.         try {  
13.             if (parent != null) {  
14.                 //如果存在父类加载器，就委派给父类加载器加载  
15.                 c = parent.loadClass(name, false);  
16.             } else {  
17.                 //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，  
18.                 //通过调用本地方法native findBootstrapClass0(String name)  
19.                 c = findBootstrapClass0(name);  
20.             }  
21.         } catch (ClassNotFoundException e) {  
22.             // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能  
23.             c = findClass(name);  
24.         }  
25.     }  
26.     if (resolve) {  
27.         resolveClass(c);  
28.     }  
29.     return c;  
30. }  
</code></pre><p>　　通过上面的代码分析，我们可以对JVM采用的双亲委派类加载机制有了更感性的认识，下面我们就接着分析一下启动类加载器、标准扩展类加载器和系统类加载器三者之间的关系。可能大家已经从各种资料上面看到了如下类似的一幅图片：</p>
<p>图三 类加载器默认委派关系图</p>
<p><img src="http://og287lnu0.bkt.clouddn.com/20140629211854375"></p>
<p>　　上面图片给人的直观印象是系统类加载器的父类加载器是标准扩展类加载器，标准扩展类加载器的父类加载器是启动类加载器，下面我们就用代码具体测试一下：</p>
<pre><code>[java] view plain copy
1. public class LoaderTest {  
2.   
3.     public static void main(String[] args) {  
4.         try {  
5.             System.out.println(ClassLoader.getSystemClassLoader());  
6.             System.out.println(ClassLoader.getSystemClassLoader().getParent());  
7.             System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());  
8.         } catch (Exception e) {  
9.             e.printStackTrace();  
10.         }  
11.     }  
12. }  
</code></pre><p>　　说明：通过java.lang.ClassLoader.getSystemClassLoader()可以直接获取到系统类加载器。</p>
<p>　　代码输出如下：</p>
<pre><code>[plain] view plain copy
1. sun.misc.Launcher$AppClassLoader@6d06d69c  
2. sun.misc.Launcher$ExtClassLoader@70dea4e  
3. null  
</code></pre><p>　　通过以上的代码输出，我们可以判定系统类加载器的父加载器是标准扩展类加载器，但是我们试图获取标准扩展类加载器的父类加载器时确得到了null，就是说标准扩展类加载器本身强制设定父类加载器为null。我们还是借助于代码分析一下。<br>　　我们首先看一下java.lang.ClassLoader抽象类中默认实现的两个构造函数：</p>
<pre><code>[java] view plain copy
1. protected ClassLoader() {  
2.     SecurityManager security = System.getSecurityManager();  
3.     if (security != null) {  
4.         security.checkCreateClassLoader();  
5.     }  
6.     //默认将父类加载器设置为系统类加载器，getSystemClassLoader()获取系统类加载器  
7.     this.parent = getSystemClassLoader();  
8.     initialized = true;  
9. }  
10.   
11. protected ClassLoader(ClassLoader parent) {  
12.     SecurityManager security = System.getSecurityManager();  
13.     if (security != null) {  
14.         security.checkCreateClassLoader();  
15.     }  
16.     //强制设置父类加载器  
17.     this.parent = parent;  
18.     initialized = true;  
19. }  
</code></pre><p>　　我们再看一下ClassLoader抽象类中parent成员的声明：</p>
<p>[java] view plain copy</p>
<ol>
<li>// The parent class loader for delegation  </li>
<li>private ClassLoader parent;<br>　　声明为私有变量的同时并没有对外提供可供派生类访问的public或者protected设置器接口（对应的setter方法），结合前面的测试代码的输出，我们可以推断出：</li>
</ol>
<p>　　1． 系统类加载器（AppClassLoader）调用ClassLoader(ClassLoader parent)构造函数将父类加载器设置为标准扩展类加载器(ExtClassLoader)。（因为如果不强制设置，默认会通过调用getSystemClassLoader()方法获取并设置成系统类加载器，这显然和测试输出结果不符。）</p>
<p>　　2． 扩展类加载器（ExtClassLoader）调用ClassLoader(ClassLoader parent)构造函数将父类加载器设置为null。（因为如果不强制设置，默认会通过调用getSystemClassLoader()方法获取并设置成系统类加载器，这显然和测试输出结果不符。）</p>
<p>　　现在我们可能会有这样的疑问：扩展类加载器（ExtClassLoader）的父类加载器被强制设置为null了，那么扩展类加载器为什么还能将加载任务委派给启动类加载器呢？</p>
<p>　　通过图四和图五可以看出，标准扩展类加载器和系统类加载器及其父类（java.NET.URLClassLoader和java.security.SecureClassLoader）都没有覆写java.lang.ClassLoader中默认的加载委派规则—loadClass（…）方法。有关java.lang.ClassLoader中默认的加载委派规则前面已经分析过，如果父加载器为null，则会调用本地方法进行启动类加载尝试。所以，图三中，启动类加载器、标准扩展类加载器和系统类加载器之间的委派关系事实上是仍就成立的。（在后面的用户自定义类加载器部分，还会做更深入的分析）。</p>
<h3 id="2-3-类加载双亲委派示例"><a href="#2-3-类加载双亲委派示例" class="headerlink" title="2.3 类加载双亲委派示例"></a>2.3 类加载双亲委派示例</h3><p>　　以上已经简要介绍了虚拟机默认使用的启动类加载器、标准扩展类加载器和系统类加载器，并以三者为例结合JDK代码对JVM默认使用的双亲委派类加载机制做了分析。下面我们就来看一个综合的例子。首先在IDE中建立一个简单的java应用工程，然后写一个简单的JavaBean如下：</p>
<pre><code>[java] view plain copy
1. package classloader.test.bean;  
2.   
3. public class TestBean {  
4.       
5.     public TestBean() { }  
6. }  
</code></pre><p>　　在现有当前工程中另外建立一测试类（ClassLoaderTest.java）内容如下：<br>　　<br>　　测试一：</p>
<pre><code>[java] view plain copy
1. package classloader.test.bean;  
2.   
3. public class ClassLoaderTest {  
4.   
5.     public static void main(String[] args) {  
6.         try {  
7.             //查看当前系统类路径中包含的路径条目  
8.             System.out.println(System.getProperty(&quot;java.class.path&quot;));  
9.             //调用加载当前类的类加载器（这里即为系统类加载器）加载TestBean  
10.             Class typeLoaded = Class.forName(&quot;classloader.test.bean.TestBean&quot;);  
11.             //查看被加载的TestBean类型是被那个类加载器加载的  
12.             System.out.println(typeLoaded.getClassLoader());  
13.         } catch (Exception e) {  
14.             e.printStackTrace();  
15.         }  
16.     }  
17. }  
</code></pre><p>　　对应的输出如下：<br>　　<br>    [plain] view plain copy</p>
<pre><code>1. C:\Users\JackZhou\Documents\NetBeansProjects\ClassLoaderTest\build\classes  
2. sun.misc.Launcher$AppClassLoader@73d16e93
</code></pre><p>说明：当前类路径默认的含有的一个条目就是工程的输出目录。</p>
<p>测试二：<br>　　将当前工程输出目录下的TestBean.class打包进test.jar剪贴到<java_runtime_home>/lib/ext目录下（现在工程输出目录下和JRE扩展目录下都有待加载类型的class文件）。再运行测试一测试代码，结果如下：</java_runtime_home></p>
<p>[plain] view plain copy</p>
<ol>
<li>C:\Users\JackZhou\Documents\NetBeansProjects\ClassLoaderTest\build\classes  </li>
<li>sun.misc.Launcher$ExtClassLoader@15db9742<br>　　对比测试一和测试二，我们明显可以验证前面说的双亲委派机制，系统类加载器在接到加载classloader.test.bean.TestBean类型的请求时，首先将请求委派给父类加载器（标准扩展类加载器），标准扩展类加载器抢先完成了加载请求。</li>
</ol>
<p>　　测试三：</p>
<p>　　将test.jar拷贝一份到<java_runtime_home>/lib下，运行测试代码，输出如下：</java_runtime_home></p>
<pre><code>[plain] view plain copy
1. C:\Users\JackZhou\Documents\NetBeansProjects\ClassLoaderTest\build\classes  
2. sun.misc.Launcher$ExtClassLoader@15db9742  
</code></pre><p>测试三和测试二输出结果一致。</p>
<p>那就是说，放置到<java_runtime_home>/lib目录下的TestBean对应的class字节码并没有被加载，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载<java_runtime_home>/lib存在的陌生类，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。做个进一步验证，删除<java_runtime_home>/lib/ext目录下和工程输出目录下的TestBean对应的class文件，然后再运行测试代码，则将会有ClassNotFoundException异常抛出。有关这个问题，大家可以在java.lang.ClassLoader中的loadClass(String name, boolean resolve)方法中设置相应断点运行测试三进行调试，会发现findBootstrapClass0()会抛出异常，然后在下面的findClass方法中被加载，当前运行的类加载器正是扩展类加载器（sun.misc.Launcher$ExtClassLoader），这一点可以通过JDT中变量视图查看验证。</java_runtime_home></java_runtime_home></java_runtime_home></p>
<h2 id="3-java程序动态扩展方式"><a href="#3-java程序动态扩展方式" class="headerlink" title="3 java程序动态扩展方式"></a>3 java程序动态扩展方式</h2><p>Java的连接模型允许用户运行时扩展引用程序，既可以通过当前虚拟机中预定义的加载器加载编译时已知的类或者接口，又允许用户自行定义类装载器，在运行时动态扩展用户的程序。通过用户自定义的类装载器，你的程序可以装载在编译时并不知道或者尚未存在的类或者接口，并动态连接它们并进行有选择的解析。</p>
<p>　　运行时动态扩展java应用程序有如下两个途径：</p>
<h3 id="3-1-调用java-lang-Class-forName-…-加载类"><a href="#3-1-调用java-lang-Class-forName-…-加载类" class="headerlink" title="3.1 调用java.lang.Class.forName(…)加载类"></a>3.1 调用java.lang.Class.forName(…)加载类</h3><p>这个方法其实在前面已经讨论过，在后面的问题2解答中说明了该方法调用会触发哪个类加载器开始加载任务。这里需要说明的是多参数版本的forName(…)方法：</p>
<pre><code>[java] view plain copy
1. public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException  
</code></pre><p>　　这里的initialize参数是很重要的。它表示在加载同时是否完成初始化的工作（说明：单参数版本的forName方法默认是完成初始化的）。有些场景下需要将initialize设置为true来强制加载同时完成初始化。例如典型的就是利用DriverManager进行JDBC驱动程序类注册的问题。因为每一个JDBC驱动程序类的静态初始化方法都用DriverManager注册驱动程序，这样才能被应用程序使用。这就要求驱动程序类必须被初始化，而不单单被加载。Class.forName的一个很常见的用法就是在加载数据库驱动的时候。如 Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。</p>
<h3 id="3-2-用户自定义类加载器"><a href="#3-2-用户自定义类加载器" class="headerlink" title="3.2 用户自定义类加载器"></a>3.2 用户自定义类加载器</h3><p>　　通过前面的分析，我们可以看出，除了和本地实现密切相关的启动类加载器之外，包括标准扩展类加载器和系统类加载器在内的所有其他类加载器我们都可以当做自定义类加载器来对待，唯一区别是是否被虚拟机默认使用。前面的内容中已经对java.lang.ClassLoader抽象类中的几个重要的方法做了介绍，这里就简要叙述一下一般用户自定义类加载器的工作流程吧（可以结合后面问题解答一起看）：</p>
<p>　　1、首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2；</p>
<p>　　2、委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，真实虚拟机中各种类加载器最终会呈现树状结构），如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3；</p>
<p>　　3、调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转而抛异常，终止加载过程（注意：这里的异常种类不止一种）。</p>
<p>　　说明：这里说的自定义类加载器是指JDK 1.2以后版本的写法，即不覆写改变java.lang.loadClass(…)已有委派逻辑情况下。</p>
<h2 id="4-常见问题分析"><a href="#4-常见问题分析" class="headerlink" title="4 常见问题分析"></a>4 常见问题分析</h2><h3 id="4-1-由不同的类加载器加载的指定类还是相同的类型吗？"><a href="#4-1-由不同的类加载器加载的指定类还是相同的类型吗？" class="headerlink" title="4.1 由不同的类加载器加载的指定类还是相同的类型吗？"></a>4.1 由不同的类加载器加载的指定类还是相同的类型吗？</h3><p>在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识，不同类加载器加载的类将被置于不同的命名空间。我们可以用两个自定义类加载器去加载某自定义类型（注意不要将自定义类型的字节码放置到系统路径或者扩展路径中，否则会被系统类加载器或扩展类加载器抢先加载），然后用获取到的两个Class实例进行java.lang.Object.equals（…）判断，将会得到不相等的结果。这个大家可以写两个自定义的类加载器去加载相同的自定义类型，然后做个判断；同时，可以测试加载java.*类型，然后再对比测试一下测试结果。</p>
<h3 id="4-2-在代码中直接调用Class-forName-String-name-方法，到底会触发那个类加载器进行类加载行为？"><a href="#4-2-在代码中直接调用Class-forName-String-name-方法，到底会触发那个类加载器进行类加载行为？" class="headerlink" title="4.2 在代码中直接调用Class.forName(String name)方法，到底会触发那个类加载器进行类加载行为？"></a>4.2 在代码中直接调用Class.forName(String name)方法，到底会触发那个类加载器进行类加载行为？</h3><p>Class.forName(String name)默认会使用调用类的类加载器来进行类加载。我们直接来分析一下对应的jdk的代码：</p>
<pre><code>[java] view plain copy
1. //java.lang.Class.java  
2. publicstatic Class&lt;?&gt; forName(String className) throws ClassNotFoundException {  
3.     return forName0(className, true, ClassLoader.getCallerClassLoader());  
4. }  
5.   
6. //java.lang.ClassLoader.java  
7. // Returns the invoker&apos;s class loader, or null if none.  
8. static ClassLoader getCallerClassLoader() {  
9.     // 获取调用类（caller）的类型  
10.     Class caller = Reflection.getCallerClass(3);  
11.     // This can be null if the VM is requesting it  
12.     if (caller == null) {  
13.         return null;  
14.     }  
15.     // 调用java.lang.Class中本地方法获取加载该调用类（caller）的ClassLoader  
16.     return caller.getClassLoader0();  
17. }  
18.   
19. //java.lang.Class.java  
20. //虚拟机本地实现，获取当前类的类加载器，前面介绍的Class的getClassLoader()也使用此方法  
21. native ClassLoader getClassLoader0();  
</code></pre><h3 id="4-3-在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？"><a href="#4-3-在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？" class="headerlink" title="4.3 在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？"></a>4.3 在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？</h3><p>　　前面讲过，在不指定父类加载器的情况下，默认采用系统类加载器。可能有人觉得不明白，现在我们来看一下JDK对应的代码实现。众所周知，我们编写自定义的类加载器直接或者间接继承自java.lang.ClassLoader抽象类，对应的无参默认构造函数实现如下：</p>
<pre><code>[java] view plain copy
1. //摘自java.lang.ClassLoader.java  
2. protected ClassLoader() {  
3.     SecurityManager security = System.getSecurityManager();  
4.     if (security != null) {  
5.         security.checkCreateClassLoader();  
6.     }  
7.     this.parent = getSystemClassLoader();  
8.     initialized = true;  
9. }  
　　我们再来看一下对应的getSystemClassLoader()方法的实现：

[java] view plain copy
1. private static synchronized void initSystemClassLoader() {  
2.     //...  
3.     sun.misc.Launcher l = sun.misc.Launcher.getLauncher();  
4.     scl = l.getClassLoader();  
5.     //...  
6. }  
</code></pre><p>　　我们可以写简单的测试代码来测试一下：</p>
<pre><code>[java] view plain copy
1. System.out.println(sun.misc.Launcher.getLauncher().getClassLoader());  
</code></pre><p>　　本机对应输出如下：</p>
<pre><code>[plain] view plain copy
1. sun.misc.Launcher$AppClassLoader@73d16e93  
</code></pre><p>　　所以，我们现在可以相信当自定义类加载器没有指定父类加载器的情况下，默认的父类加载器即为系统类加载器。同时，我们可以得出如下结论：即使用户自定义类加载器不指定父类加载器，那么，同样可以加载如下三个地方的类：</p>
<p>　　1. <java_runtime_home>/lib下的类；</java_runtime_home></p>
<p>　　2. &lt; Java_Runtime_Home &gt;/lib/ext下或者由系统变量java.ext.dir指定位置中的类；</p>
<p>　　3. 当前工程类路径下或者由系统变量java.class.path指定位置中的类。</p>
<h3 id="4-4-在编写自定义类加载器时，如果将父类加载器强制设置为null，那么会有什么影响？如果自定义的类加载器不能加载指定类，就肯定会加载失败吗？"><a href="#4-4-在编写自定义类加载器时，如果将父类加载器强制设置为null，那么会有什么影响？如果自定义的类加载器不能加载指定类，就肯定会加载失败吗？" class="headerlink" title="4.4 在编写自定义类加载器时，如果将父类加载器强制设置为null，那么会有什么影响？如果自定义的类加载器不能加载指定类，就肯定会加载失败吗？"></a>4.4 在编写自定义类加载器时，如果将父类加载器强制设置为null，那么会有什么影响？如果自定义的类加载器不能加载指定类，就肯定会加载失败吗？</h3><p>　　JVM规范中规定如果用户自定义的类加载器将父类加载器强制设置为null，那么会自动将启动类加载器设置为当前用户自定义类加载器的父类加载器（这个问题前面已经分析过了）。同时，我们可以得出如下结论：</p>
<p>　　即使用户自定义类加载器不指定父类加载器，那么，同样可以加载到<java_runtime_home>/lib下的类，但此时就不能够加载<java_runtime_home>/lib/ext目录下的类了。</java_runtime_home></java_runtime_home></p>
<p>　　说明：问题3和问题4的推断结论是基于用户自定义的类加载器本身延续了java.lang.ClassLoader.loadClass（…）默认委派逻辑，如果用户对这一默认委派逻辑进行了改变，以上推断结论就不一定成立了，详见问题5。</p>
<h3 id="4-5-编写自定义类加载器时，一般有哪些注意点？"><a href="#4-5-编写自定义类加载器时，一般有哪些注意点？" class="headerlink" title="4.5 编写自定义类加载器时，一般有哪些注意点？"></a>4.5 编写自定义类加载器时，一般有哪些注意点？</h3><p>　　1、一般尽量不要覆写已有的loadClass(…)方法中的委派逻辑</p>
<p>　　一般在JDK 1.2之前的版本才这样做，而且事实证明，这样做极有可能引起系统默认的类加载器不能正常工作。在JVM规范和JDK文档中（1.2或者以后版本中），都没有建议用户覆写loadClass(…)方法，相比而言，明确提示开发者在开发自定义的类加载器时覆写findClass(…)逻辑。举一个例子来验证该问题：</p>
<pre><code>[java] view plain copy
1. //用户自定义类加载器WrongClassLoader.Java（覆写loadClass逻辑）  
2. public class WrongClassLoader extends ClassLoader {  
3.   
4.     public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {  
5.         return this.findClass(name);  
6.     }  
7.   
8.     protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {  
9.         // 假设此处只是到工程以外的特定目录D:\library下去加载类  
10.         // 具体实现代码省略  
11.     }  
12. }  
13. 
</code></pre><p>　　通过前面的分析我们已经知道，这个自定义类加载器WrongClassLoader的默认类加载器是系统类加载器，但是现在问题4种的结论就不成立了。大家可以简单测试一下，现在<java_runtime_home>/lib、&lt; Java_Runtime_Home &gt;/lib/ext和工程类路径上的类都加载不上了。</java_runtime_home></p>
<pre><code>[java] view plain copy
1. //问题5测试代码一  
2. public class WrongClassLoaderTest {  
3.   
4.     publicstaticvoid main(String[] args) {  
5.         try {  
6.             WrongClassLoader loader = new WrongClassLoader();  
7.             Class classLoaded = loader.loadClass(&quot;beans.Account&quot;);  
8.             System.out.println(classLoaded.getName());  
9.             System.out.println(classLoaded.getClassLoader());  
10.         } catch (Exception e) {  
11.             e.printStackTrace();  
12.         }  
13.     }  
14. }  
</code></pre><p>　　这里D:”classes”beans”Account.class是物理存在的。输出结果：</p>
<p>[plain] view plain copy</p>
<ol>
<li><p>java.io.FileNotFoundException: D:”classes”java”lang”Object.class (系统找不到指定的路径。)  </p>
<ol>
<li>at java.io.FileInputStream.open(Native Method)  </li>
<li>at java.io.FileInputStream.<init>(FileInputStream.java:106)  </init></li>
<li>at WrongClassLoader.findClass(WrongClassLoader.java:40)  </li>
<li>at WrongClassLoader.loadClass(WrongClassLoader.java:29)  </li>
<li>at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)  </li>
<li>at java.lang.ClassLoader.defineClass1(Native Method)  </li>
<li>at java.lang.ClassLoader.defineClass(ClassLoader.java:620)  </li>
<li>at java.lang.ClassLoader.defineClass(ClassLoader.java:400)  </li>
<li>at WrongClassLoader.findClass(WrongClassLoader.java:43)  </li>
<li>at WrongClassLoader.loadClass(WrongClassLoader.java:29)  </li>
<li>at WrongClassLoaderTest.main(WrongClassLoaderTest.java:27)  </li>
<li>Exception in thread “main” java.lang.NoClassDefFoundError: java/lang/Object  </li>
<li>at java.lang.ClassLoader.defineClass1(Native Method)  </li>
<li>at java.lang.ClassLoader.defineClass(ClassLoader.java:620)  </li>
<li>at java.lang.ClassLoader.defineClass(ClassLoader.java:400)  </li>
<li>at WrongClassLoader.findClass(WrongClassLoader.java:43)  </li>
<li>at WrongClassLoader.loadClass(WrongClassLoader.java:29)  </li>
<li>at WrongClassLoaderTest.main(WrongClassLoaderTest.java:27)  </li>
</ol>
</li>
</ol>
<p>　　这说明，连要加载的类型的超类型java.lang.Object都加载不到了。这里列举的由于覆写loadClass()引起的逻辑错误明显是比较简单的，实际引起的逻辑错误可能复杂的多。</p>
<pre><code>[java] view plain copy
1. //问题5测试二  
2. //用户自定义类加载器WrongClassLoader.Java(不覆写loadClass逻辑)  
3. public class WrongClassLoader extends ClassLoader {  
4.   
5.     protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {  
6.         //假设此处只是到工程以外的特定目录D:\library下去加载类  
7.         //具体实现代码省略  
8.     }  
9. }  
</code></pre><p>　　将自定义类加载器代码WrongClassLoader.Java做以上修改后，再运行测试代码，输出结果如下：</p>
<pre><code>[plain] view plain copy
1. beans.Account  
2. WrongClassLoader@1c78e57 
</code></pre><p>　　2、正确设置父类加载器</p>
<p>　　通过上面问题4和问题5的分析我们应该已经理解，个人觉得这是自定义用户类加载器时最重要的一点，但常常被忽略或者轻易带过。有了前面JDK代码的分析作为基础，我想现在大家都可以随便举出例子了。</p>
<p>　　3、保证findClass(String name)方法的逻辑正确性</p>
<p>　　事先尽量准确理解待定义的类加载器要完成的加载任务，确保最大程度上能够获取到对应的字节码内容。</p>
<h3 id="4-6-如何在运行时判断系统类加载器能加载哪些路径下的类？"><a href="#4-6-如何在运行时判断系统类加载器能加载哪些路径下的类？" class="headerlink" title="4.6 如何在运行时判断系统类加载器能加载哪些路径下的类？"></a>4.6 如何在运行时判断系统类加载器能加载哪些路径下的类？</h3><p>　　一是可以直接调用ClassLoader.getSystemClassLoader()或者其他方式获取到系统类加载器（系统类加载器和扩展类加载器本身都派生自URLClassLoader），调用URLClassLoader中的getURLs()方法可以获取到。</p>
<p>　　二是可以直接通过获取系统属性java.class.path来查看当前类路径上的条目信息 ：System.getProperty(“java.class.path”)。</p>
<h3 id="4-7-如何在运行时判断标准扩展类加载器能加载哪些路径下的类？"><a href="#4-7-如何在运行时判断标准扩展类加载器能加载哪些路径下的类？" class="headerlink" title="4.7 如何在运行时判断标准扩展类加载器能加载哪些路径下的类？"></a>4.7 如何在运行时判断标准扩展类加载器能加载哪些路径下的类？</h3><p>　　方法之一：</p>
<pre><code>[java] view plain copy
1. import java.net.URL;  
2. import java.net.URLClassLoader;  
3.   
4. public class ClassLoaderTest {  
5.   
6.     /** 
7.      * @param args the command line arguments 
8.      */  
9.     public static void main(String[] args) {  
10.         try {  
11.             URL[] extURLs = ((URLClassLoader) ClassLoader.getSystemClassLoader().getParent()).getURLs();  
12.             for (int i = 0; i &lt; extURLs.length; i++) {  
13.                 System.out.println(extURLs[i]);  
14.             }  
15.         } catch (Exception e) {  
16.             //…  
17.         }  
18.     }  
19. }  
</code></pre><p>　　本机对应输出如下：</p>
<pre><code>[plain] view plain copy
1. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/access-bridge-64.jar  
2. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/cldrdata.jar  
3. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/dnsns.jar  
4. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/jaccess.jar  
5. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/jfxrt.jar  
6. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/localedata.jar  
7. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/nashorn.jar  
8. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunec.jar  
9. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunjce_provider.jar  
10. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunmscapi.jar  
11. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunpkcs11.jar  
12. file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/zipfs.jar  
</code></pre><h2 id="以下未深入研究，故没有整理格式"><a href="#以下未深入研究，故没有整理格式" class="headerlink" title="以下未深入研究，故没有整理格式"></a>以下未深入研究，故没有整理格式</h2><p>5 开发自己的类加载器</p>
<p>　　在前面介绍类加载器的代理委派模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用defineClass来实现的；而启动类的加载过程是通过调用loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在Java虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。</p>
<p>　　方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。</p>
<p>　　类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。</p>
<p>　　在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，您还是需要为应用开发出自己的类加载器。比如您的应用通过网络来传输Java类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候您就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在Java虚拟机中运行的类来。下面将通过两个具体的实例来说明类加载器的开发。</p>
<p>5.1 文件系统类加载器</p>
<p>　　第一个类加载器用来加载存储在文件系统上的Java字节代码。完整的实现如下所示。</p>
<p>[java] view plain copy</p>
<ol>
<li>package classloader;  </li>
<li></li>
<li>import java.io.ByteArrayOutputStream;  </li>
<li>import java.io.File;  </li>
<li>import java.io.FileInputStream;  </li>
<li>import java.io.IOException;  </li>
<li>import java.io.InputStream;  </li>
<li></li>
<li>// 文件系统类加载器  </li>
<li>public class FileSystemClassLoader extends ClassLoader {  </li>
<li></li>
<li>private String rootDir;  </li>
<li></li>
<li>public FileSystemClassLoader(String rootDir) {  </li>
<li>this.rootDir = rootDir;  </li>
<li>}  </li>
<li></li>
<li>// 获取类的字节码  </li>
<li>@Override  </li>
<li>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {  </li>
<li>byte[] classData = getClassData(name);  // 获取类的字节数组  </li>
<li>if (classData == null) {  </li>
<li>throw new ClassNotFoundException();  </li>
<li>} else {  </li>
<li>return defineClass(name, classData, 0, classData.length);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private byte[] getClassData(String className) {  </li>
<li>// 读取类文件的字节  </li>
<li>String path = classNameToPath(className);  </li>
<li>try {  </li>
<li>InputStream ins = new FileInputStream(path);  </li>
<li>ByteArrayOutputStream baos = new ByteArrayOutputStream();  </li>
<li>int bufferSize = 4096;  </li>
<li>byte[] buffer = new byte[bufferSize];  </li>
<li>int bytesNumRead = 0;  </li>
<li>// 读取类文件的字节码  </li>
<li>while ((bytesNumRead = ins.read(buffer)) != -1) {  </li>
<li>baos.write(buffer, 0, bytesNumRead);  </li>
<li>}  </li>
<li>return baos.toByteArray();  </li>
<li>} catch (IOException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>return null;  </li>
<li>}  </li>
<li></li>
<li>private String classNameToPath(String className) {  </li>
<li>// 得到类文件的完全路径  </li>
<li>return rootDir + File.separatorChar  </li>
<li><ul>
<li>className.replace(‘.’, File.separatorChar) + “.class”;  </li>
</ul>
</li>
<li>}  </li>
<li>}<br>　　如上所示，类 FileSystemClassLoader继承自类java.lang.ClassLoader。在java.lang.ClassLoader类的常用方法中，一般来说，自己开发的类加载器只需要覆写 findClass(String name)方法即可。java.lang.ClassLoader类的方法loadClass()封装了前面提到的代理模式的实现。该方法会首先调用findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。</li>
</ol>
<p>　　类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。<br>　　加载本地文件系统上的类，示例如下：</p>
<p>[java] view plain copy</p>
<ol>
<li>package com.example;  </li>
<li></li>
<li>public class Sample {  </li>
<li></li>
<li>private Sample instance;  </li>
<li></li>
<li>public void setSample(Object instance) {  </li>
<li>System.out.println(instance.toString());  </li>
<li>this.instance = (Sample) instance;  </li>
<li>}  </li>
<li>}<br>[java] view plain copy</li>
<li>package classloader;  </li>
<li></li>
<li>import java.lang.reflect.Method;  </li>
<li></li>
<li>public class ClassIdentity {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>new ClassIdentity().testClassIdentity();  </li>
<li>}  </li>
<li></li>
<li>public void testClassIdentity() {  </li>
<li>String classDataRootPath = “C:\Users\JackZhou\Documents\NetBeansProjects\classloader\build\classes”;  </li>
<li>FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath);  </li>
<li>FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath);  </li>
<li>String className = “com.example.Sample”;  </li>
<li>try {  </li>
<li>Class&lt;?&gt; class1 = fscl1.loadClass(className);  // 加载Sample类  </li>
<li>Object obj1 = class1.newInstance();  // 创建对象  </li>
<li>Class&lt;?&gt; class2 = fscl2.loadClass(className);  </li>
<li>Object obj2 = class2.newInstance();  </li>
<li>Method setSampleMethod = class1.getMethod(“setSample”, java.lang.Object.class);  </li>
<li>setSampleMethod.invoke(obj1, obj2);  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}<br>　　运行输出：com.example.Sample@7852e922</li>
</ol>
<p>5.2 网络类加载器</p>
<p>　　下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。即基本的场景是：Java 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。</p>
<p>　　类 NetworkClassLoader负责通过网络下载Java类字节代码并定义出Java类。它的实现与FileSystemClassLoader类似。<br>[java] view plain copy</p>
<ol>
<li>package classloader;  </li>
<li></li>
<li>import java.io.ByteArrayOutputStream;  </li>
<li>import java.io.InputStream;  </li>
<li>import java.net.URL;  </li>
<li></li>
<li>public class NetworkClassLoader extends ClassLoader {  </li>
<li></li>
<li>private String rootUrl;  </li>
<li></li>
<li>public NetworkClassLoader(String rootUrl) {  </li>
<li>// 指定URL  </li>
<li>this.rootUrl = rootUrl;  </li>
<li>}  </li>
<li></li>
<li>// 获取类的字节码  </li>
<li>@Override  </li>
<li>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {  </li>
<li>byte[] classData = getClassData(name);  </li>
<li>if (classData == null) {  </li>
<li>throw new ClassNotFoundException();  </li>
<li>} else {  </li>
<li>return defineClass(name, classData, 0, classData.length);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>private byte[] getClassData(String className) {  </li>
<li>// 从网络上读取的类的字节  </li>
<li>String path = classNameToPath(className);  </li>
<li>try {  </li>
<li>URL url = new URL(path);  </li>
<li>InputStream ins = url.openStream();  </li>
<li>ByteArrayOutputStream baos = new ByteArrayOutputStream();  </li>
<li>int bufferSize = 4096;  </li>
<li>byte[] buffer = new byte[bufferSize];  </li>
<li>int bytesNumRead = 0;  </li>
<li>// 读取类文件的字节  </li>
<li>while ((bytesNumRead = ins.read(buffer)) != -1) {  </li>
<li>baos.write(buffer, 0, bytesNumRead);  </li>
<li>}  </li>
<li>return baos.toByteArray();  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>return null;  </li>
<li>}  </li>
<li></li>
<li>private String classNameToPath(String className) {  </li>
<li>// 得到类文件的URL  </li>
<li>return rootUrl + “/“  </li>
<li><ul>
<li>className.replace(‘.’, ‘/‘) + “.class”;  </li>
</ul>
</li>
<li>}  </li>
<li>}<br>　　在通过NetworkClassLoader加载了某个版本的类之后，一般有两种做法来使用它。第一种做法是使用Java反射API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用Java反射API可以直接调用Java类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。我们使用接口的方式。示例如下：</li>
</ol>
<p>　　客户端接口：</p>
<p>[java] view plain copy</p>
<ol>
<li>package classloader;  </li>
<li></li>
<li>public interface Versioned {  </li>
<li></li>
<li>String getVersion();  </li>
<li>}<br>[java] view plain copy</li>
<li>package classloader;  </li>
<li></li>
<li>public interface ICalculator extends Versioned {  </li>
<li></li>
<li>String calculate(String expression);  </li>
<li>}<br>　　网络上的不同版本的类：</li>
</ol>
<p>[java] view plain copy</p>
<ol>
<li>package com.example;  </li>
<li></li>
<li>import classloader.ICalculator;  </li>
<li></li>
<li>public class CalculatorBasic implements ICalculator {  </li>
<li></li>
<li>@Override  </li>
<li>public String calculate(String expression) {  </li>
<li>return expression;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public String getVersion() {  </li>
<li>return “1.0”;  </li>
<li>}  </li>
<li></li>
<li>}<br>[java] view plain copy</li>
<li>package com.example;  </li>
<li></li>
<li>import classloader.ICalculator;  </li>
<li></li>
<li>public class CalculatorAdvanced implements ICalculator {  </li>
<li></li>
<li>@Override  </li>
<li>public String calculate(String expression) {  </li>
<li>return “Result is “ + expression;  </li>
<li>}  </li>
<li></li>
<li>@Override  </li>
<li>public String getVersion() {  </li>
<li>return “2.0”;  </li>
<li>}  </li>
<li></li>
<li>}<br>　　在客户端加载网络上的类的过程：</li>
</ol>
<p>[java] view plain copy</p>
<ol>
<li>package classloader;  </li>
<li></li>
<li>public class CalculatorTest {  </li>
<li></li>
<li>public static void main(String[] args) {  </li>
<li>String url = “<a href="http://localhost:8080/ClassloaderTest/classes" target="_blank" rel="external">http://localhost:8080/ClassloaderTest/classes</a>“;  </li>
<li>NetworkClassLoader ncl = new NetworkClassLoader(url);  </li>
<li>String basicClassName = “com.example.CalculatorBasic”;  </li>
<li>String advancedClassName = “com.example.CalculatorAdvanced”;  </li>
<li>try {  </li>
<li>Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);  // 加载一个版本的类  </li>
<li>ICalculator calculator = (ICalculator) clazz.newInstance();  // 创建对象  </li>
<li>System.out.println(calculator.getVersion());  </li>
<li>clazz = ncl.loadClass(advancedClassName);  // 加载另一个版本的类  </li>
<li>calculator = (ICalculator) clazz.newInstance();  </li>
<li>System.out.println(calculator.getVersion());  </li>
<li>} catch (Exception e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>}  </li>
</ol>
<p>参考文献：</p>
<p><a href="http://www.blogjava.net/zhuxing/archive/2008/08/08/220841.html" target="_blank" rel="external">http://www.blogjava.net/zhuxing/archive/2008/08/08/220841.html</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a></p>
<p>顶<br>19<br>1 线程上下文类加载器</p>
<p>　　线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 Java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p>
<p>　　前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的 DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；<br>SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。</p>
<p>　　线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p>
<p>　　Java默认的线程上下文类加载器是系统类加载器(AppClassLoader)。以下代码摘自sun.misc.Launch的无参构造函数Launch()。</p>
<p>[java] view plain copy</p>
<ol>
<li>// Now create the class loader to use to launch the application  </li>
<li>try {  </li>
<li>loader = AppClassLoader.getAppClassLoader(extcl);  </li>
<li>} catch (IOException e) {  </li>
<li>throw new InternalError(  </li>
<li>“Could not create application class loader” );  </li>
<li>}  </li>
<li></li>
<li>// Also set the context class loader for the primordial thread.  </li>
<li>Thread.currentThread().setContextClassLoader(loader);<br>　　使用线程上下文类加载器，可以在执行线程中抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类。典型的例子有：通过线程上下文来加载第三方库jndi实现，而不依赖于双亲委派。大部分Java application服务器(jboss, tomcat..)也是采用contextClassLoader来处理web服务。还有一些采用hot swap特性的框架，也使用了线程上下文类加载器，比如 seasar (full stack framework in japenese)。</li>
</ol>
<p>　　线程上下文从根本解决了一般应用不能违背双亲委派模式的问题。使java类加载体系显得更灵活。随着多核时代的来临，相信多线程开发将会越来越多地进入程序员的实际编码过程中。因此，在编写基础设施时， 通过使用线程上下文来加载类，应该是一个很好的选择。</p>
<p>　　当然，好东西都有利弊。使用线程上下文加载类，也要注意保证多个需要通信的线程间的类加载器应该是同一个，防止因为不同的类加载器导致类型转换异常(ClassCastException)。<br>　　defineClass(String name, byte[] b, int off, int len,ProtectionDomain protectionDomain)是java.lang.Classloader提供给开发人员，用来自定义加载class的接口。使用该接口，可以动态的加载class文件。例如在jdk中，URLClassLoader是配合findClass方法来使用defineClass，可以从网络或硬盘上加载class。而使用类加载接口，并加上自己的实现逻辑，还可以定制出更多的高级特性。</p>
<p>　　下面是一个简单的hot swap类加载器实现。hot swap即热插拔的意思，这里表示一个类已经被一个加载器加载了以后，在不卸载它的情况下重新再加载它一次。我们知道Java缺省的加载器对相同全名的类只会加载一次，以后直接从缓存中取这个Class object。因此要实现hot swap，必须在加载的那一刻进行拦截，先判断是否已经加载，若是则重新加载一次，否则直接首次加载它。我们从URLClassLoader继承，加载类的过程都代理给系统类加载器URLClassLoader中的相应方法来完成。</p>
<p>[java] view plain copy</p>
<ol>
<li>package classloader;  </li>
<li></li>
<li>import java.net.URL;  </li>
<li>import java.net.URLClassLoader;  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>可以重新载入同名类的类加载器实现 </li>
</ul>
</li>
<li><ul>
<li>放弃了双亲委派的加载链模式，需要外部维护重载后的类的成员变量状态 </li>
</ul>
</li>
<li>*/  </li>
<li>public class HotSwapClassLoader extends URLClassLoader {  </li>
<li></li>
<li>public HotSwapClassLoader(URL[] urls) {  </li>
<li>super(urls);  </li>
<li>}  </li>
<li></li>
<li>public HotSwapClassLoader(URL[] urls, ClassLoader parent) {  </li>
<li>super(urls, parent);  </li>
<li>}  </li>
<li></li>
<li>// 下面的两个重载load方法实现类的加载，仿照ClassLoader中的两个loadClass()  </li>
<li>// 具体的加载过程代理给父类中的相应方法来完成  </li>
<li>public Class&lt;?&gt; load(String name) throws ClassNotFoundException {  </li>
<li>return load(name, false);  </li>
<li>}  </li>
<li></li>
<li>public Class&lt;?&gt; load(String name, boolean resolve) throws ClassNotFoundException {  </li>
<li>// 若类已经被加载，则重新再加载一次  </li>
<li>if (null != super.findLoadedClass(name)) {  </li>
<li>return reload(name, resolve);  </li>
<li>}  </li>
<li>// 否则用findClass()首次加载它  </li>
<li>Class&lt;?&gt; clazz = super.findClass(name);  </li>
<li>if (resolve) {  </li>
<li>super.resolveClass(clazz);  </li>
<li>}  </li>
<li>return clazz;  </li>
<li>}  </li>
<li></li>
<li>public Class&lt;?&gt; reload(String name, boolean resolve) throws ClassNotFoundException {  </li>
<li>return new HotSwapClassLoader(super.getURLs(), super.getParent()).load(  </li>
<li>name, resolve);  </li>
<li>}  </li>
<li>}<br>　　两个重载的load方法参数与ClassLoader类中的两个loadClass()相似。在load的实现中，用findLoadedClass()查找指定的类是否已经被祖先加载器加载了，若已加载则重新再加载一次，从而放弃了双亲委派的方式（这种方式只会加载一次）。若没有加载则用自身的findClass()来首次加载它。</li>
</ol>
<p>　　下面是使用示例：</p>
<p>[java] view plain copy</p>
<ol>
<li>package classloader;  </li>
<li></li>
<li>public class A {  </li>
<li></li>
<li>private B b;  </li>
<li></li>
<li>public void setB(B b) {  </li>
<li>this.b = b;  </li>
<li>}  </li>
<li></li>
<li>public B getB() {  </li>
<li>return b;  </li>
<li>}  </li>
<li>}<br>[java] view plain copy</li>
<li>package classloader;  </li>
<li></li>
<li>public class B {  </li>
<li></li>
<li>}<br>[java] view plain copy</li>
<li>package classloader;  </li>
<li></li>
<li>import java.lang.reflect.InvocationTargetException;  </li>
<li>import java.lang.reflect.Method;  </li>
<li>import java.net.MalformedURLException;  </li>
<li>import java.net.URL;  </li>
<li></li>
<li>public class TestHotSwap {  </li>
<li></li>
<li>public static void main(String args[]) throws MalformedURLException {  </li>
<li>A a = new A();  // 加载类A  </li>
<li>B b = new B();  // 加载类B  </li>
<li>a.setB(b);  // A引用了B，把b对象拷贝到A.b  </li>
<li>System.out.printf(“A classLoader is %s\n”, a.getClass().getClassLoader());  </li>
<li>System.out.printf(“B classLoader is %s\n”, b.getClass().getClassLoader());  </li>
<li>System.out.printf(“A.b classLoader is %s\n”, a.getB().getClass().getClassLoader());  </li>
<li></li>
<li>try {  </li>
<li>URL[] urls = new URL[]{ new URL(“file:///C:/Users/JackZhou/Documents/NetBeansProjects/classloader/build/classes/“) };  </li>
<li>HotSwapClassLoader c1 = new HotSwapClassLoader(urls, a.getClass().getClassLoader());  </li>
<li>Class clazz = c1.load(“classloader.A”);  // 用hot swap重新加载类A  </li>
<li>Object aInstance = clazz.newInstance();  // 创建A类对象  </li>
<li>Method method1 = clazz.getMethod(“setB”, B.class);  // 获取setB(B b)方法  </li>
<li>method1.invoke(aInstance, b);    // 调用setB(b)方法，重新把b对象拷贝到A.b  </li>
<li>Method method2 = clazz.getMethod(“getB”);  // 获取getB()方法  </li>
<li>Object bInstance = method2.invoke(aInstance);  // 调用getB()方法  </li>
<li>System.out.printf(“Reloaded A.b classLoader is %s\n”, bInstance.getClass().getClassLoader());  </li>
<li>} catch (MalformedURLException | ClassNotFoundException |   </li>
<li>InstantiationException | IllegalAccessException |   </li>
<li>NoSuchMethodException | SecurityException |   </li>
<li>IllegalArgumentException | InvocationTargetException e) {  </li>
<li>e.printStackTrace();  </li>
<li>}  </li>
<li>}  </li>
<li>}<br>　　运行输出：<br>[java] view plain copy</li>
<li>A classLoader is sun.misc.Launcher$AppClassLoader@73d16e93  </li>
<li>B classLoader is sun.misc.Launcher$AppClassLoader@73d16e93  </li>
<li>A.b classLoader is sun.misc.Launcher$AppClassLoader@73d16e93  </li>
<li>Reloaded A.b classLoader is sun.misc.Launcher$AppClassLoader@73d16e93<br>　　HotSwapClassLoader加载器的作用是重新加载同名的类。为了实现hot swap，一个类在加载过后，若重新再加载一次，则新的Class object的状态会改变，老的状态数据需要通过其他方式拷贝到重新加载过的类生成的全新Class object实例中来。上面A类引用了B类，加载A时也会加载B（如果B已经加载，则直接从缓存中取出）。在重新加载A后，其Class object中的成员b会重置，因此要重新调用setB(b)拷贝一次。你可以注释掉这行代码，再运行会抛出java.lang.NullPointerException，指示A.b为null。</li>
</ol>
<p>　　注意新的A Class object实例所依赖的B类Class object，如果它与老的B Class object实例不是同一个类加载器加载的， 将会抛出类型转换异常(ClassCastException)，表示两种不同的类。因此在重新加载A后，要特别注意给它的B类成员b传入外部值时，它们是否由同一个类加载器加载。为了解决这种问题， HotSwapClassLoader自定义的l/oad方法中，当前类（类A）是由自身classLoader加载的， 而内部依赖的类（类B）还是老对象的classLoader加载的。</p>
<p>2 何时使用Thread.getContextClassLoader()?</p>
<p>　　这是一个很常见的问题，但答案却很难回答。这个问题通常在需要动态加载类和资源的系统编程时会遇到。总的说来动态加载资源时，往往需要从三种类加载器里选择：系统或程序的类加载器、当前类加载器、以及当前线程的上下文类加载器。在程序中应该使用何种类加载器呢？</p>
<p>　　系统类加载器通常不会使用。此类加载器处理启动应用程序时classpath指定的类，可以通过ClassLoader.getSystemClassLoader()来获得。所有的ClassLoader.getSystemXXX()接口也是通过这个类加载器加载的。一般不要显式调用这些方法，应该让其他类加载器代理到系统类加载器上。由于系统类加载器是JVM最后创建的类加载器，这样代码只会适应于简单命令行启动的程序。一旦代码移植到EJB、Web应用或者Java Web Start应用程序中，程序肯定不能正确执行。</p>
<p>　　因此一般只有两种选择，当前类加载器和线程上下文类加载器。当前类加载器是指当前方法所在类的加载器。这个类加载器是运行时类解析使用的加载器，Class.forName(String)和Class.getResource(String)也使用该类加载器。代码中X.class的写法使用的类加载器也是这个类加载器。</p>
<p>　　线程上下文类加载器在java 2(J2SE)时引入。每个线程都有一个关联的上下文类加载器。如果你使用new Thread()方式生成新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。Web应用和Java企业级应用中，应用服务器经常要使用复杂的类加载器结构来实现JNDI（Java命名和目录接口)、线程池、组件热部署等功能，因此理解这一点尤其重要。</p>
<p>　　为什么要引入线程的上下文类加载器？将它引入J2SE并不是纯粹的噱头，由于Sun没有提供充分的文档解释说明这一点，这使许多开发者很糊涂。实际上，上下文类加载器为同样在J2SE中引入的类加载代理机制提供了后门。通常JVM中的类加载器是按照层次结构组织的，目的是每个类加载器（除了启动整个JVM的原初类加载器）都有一个父类加载器。当类加载请求到来时，类加载器通常首先将请求代理给父类加载器。只有当父类加载器失败后，它才试图按照自己的算法查找并定义当前类。</p>
<p>　　有时这种模式并不能总是奏效。这通常发生在JVM核心代码必须动态加载由应用程序动态提供的资源时。拿JNDI为例，它的核心是由JRE核心类(rt.jar)实现的。但这些核心JNDI类必须能加载由第三方厂商提供的JNDI实现。这种情况下调用父类加载器（原初类加载器）来加载只有其子类加载器可见的类，这种代理机制就会失效。<br>解决办法就是让核心JNDI类使用线程上下文类加载器，从而有效的打通类加载器层次结构，逆着代理机制的方向使用类加载器。</p>
<p>　　顺便提一下，XML解析API(JAXP)也是使用此种机制。当JAXP还是J2SE扩展时，XML解析器使用当前类加载器方法来加载解析器实现。但当JAXP成为J2SE核心代码后，类加载机制就换成了使用线程上下文加载器，这和JNDI的原因相似。</p>
<p>　　好了，现在我们明白了问题的关键：这两种选择不可能适应所有情况。一些人认为线程上下文类加载器应成为新的标准。但这在不同JVM线程共享数据来沟通时，就会使类加载器的结构乱七八糟。除非所有线程都使用同一个上下文类加载器。而且，使用当前类加载器已成为缺省规则，它们广泛应用在类声明、Class.forName等情景中。即使你想尽可能只使用上下文类加载器，总是有这样那样的代码不是你所能控制的。这些代码都使用代理到当前类加载器的模式。混杂使用代理模式是很危险的。</p>
<p>　　更为糟糕的是，某些应用服务器将当前类加载器和上下文类加器分别设置成不同的ClassLoader实例。虽然它们拥有相同的类路径，但是它们之间并不存在父子代理关系。想想这为什么可怕：记住加载并定义某个类的类加载器是虚拟机内部标识该类的组成部分，如果当前类加载器加载类X并接着执行它，如JNDI查找类型为Y的数据，上下文类加载器能够加载并定义Y，这个Y的定义和当前类加载器加载的相同名称的类就不是同一个，使用隐式类型转换就会造成异常。</p>
<p>　　这种混乱的状况还将在Java中存在很长时间。在J2SE中还包括以下的功能使用不同的类加载器：</p>
<p>　　（1）JNDI使用线程上下文类加载器。</p>
<p>　　（2）Class.getResource()和Class.forName()使用当前类加载器。</p>
<p>　　（3）JAXP使用上下文类加载器。</p>
<p>　　（4）java.util.ResourceBundle使用调用者的当前类加载器。</p>
<p>　　（5）URL协议处理器使用java.protocol.handler.pkgs系统属性并只使用系统类加载器。</p>
<p>　　（6）Java序列化API缺省使用调用者当前的类加载器。</p>
<p>　　这些类加载器非常混乱，没有在J2SE文档中给以清晰明确的说明。</p>
<p>　　该如何选择类加载器？</p>
<p>　　如若代码是限于某些特定框架，这些框架有着特定加载规则，则不要做任何改动，让框架开发者来保证其工作（比如应用服务器提供商，尽管他们并不能总是做对）。如在Web应用和EJB中，要使用Class.gerResource来加载资源。<br>　　在其他情况下，我们可以自己来选择最合适的类加载器。可以使用策略模式来设计选择机制。其思想是将“总是使用上下文类加载器”或者“总是使用当前类加载器”的决策同具体实现逻辑分离开。往往设计之初是很难预测何种类加载策略是合适的，该设计能够让你可以后来修改类加载策略。</p>
<p>　　考虑使用下面的代码，这是作者本人在工作中发现的经验。这儿有一个缺省实现，应该可以适应大部分工作场景：</p>
<p>[java] view plain copy</p>
<ol>
<li>package classloader.context;  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>类加载上下文，持有要加载的类 </li>
</ul>
</li>
<li>*/  </li>
<li>public class ClassLoadContext {  </li>
<li></li>
<li>private final Class m_caller;  </li>
<li></li>
<li>public final Class getCallerClass() {  </li>
<li>return m_caller;  </li>
<li>}  </li>
<li></li>
<li>ClassLoadContext(final Class caller) {  </li>
<li>m_caller = caller;  </li>
<li>}  </li>
<li>}  </li>
</ol>
<p>[java] view plain copy</p>
<ol>
<li>package classloader.context;  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>类加载策略接口 </li>
</ul>
</li>
<li>*/  </li>
<li>public interface IClassLoadStrategy {  </li>
<li></li>
<li>ClassLoader getClassLoader(ClassLoadContext ctx);  </li>
<li>}<br>[java] view plain copy</li>
<li>/** </li>
<li><ul>
<li>缺省的类加载策略，可以适应大部分工作场景 </li>
</ul>
</li>
<li>*/  </li>
<li>public class DefaultClassLoadStrategy implements IClassLoadStrategy {  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>为ctx返回最合适的类加载器，从系统类加载器、当前类加载器 </li>
</ul>
</li>
<li><ul>
<li>和当前线程上下文类加载中选择一个最底层的加载器 </li>
</ul>
</li>
<li><ul>
<li>@param ctx </li>
</ul>
</li>
<li><ul>
<li>@return  </li>
</ul>
</li>
<li>*/  </li>
<li>@Override  </li>
<li>public ClassLoader getClassLoader(final ClassLoadContext ctx) {  </li>
<li>final ClassLoader callerLoader = ctx.getCallerClass().getClassLoader();  </li>
<li>final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();  </li>
<li>ClassLoader result;  </li>
<li></li>
<li>// If ‘callerLoader’ and ‘contextLoader’ are in a parent-child  </li>
<li>// relationship, always choose the child:  </li>
<li>if (isChild(contextLoader, callerLoader)) {  </li>
<li>result = callerLoader;  </li>
<li>} else if (isChild(callerLoader, contextLoader)) {  </li>
<li>result = contextLoader;  </li>
<li>} else {  </li>
<li>// This else branch could be merged into the previous one,  </li>
<li>// but I show it here to emphasize the ambiguous case:  </li>
<li>result = contextLoader;  </li>
<li>}  </li>
<li>final ClassLoader systemLoader = ClassLoader.getSystemClassLoader();  </li>
<li>// Precaution for when deployed as a bootstrap or extension class:  </li>
<li>if (isChild(result, systemLoader)) {  </li>
<li>result = systemLoader;  </li>
<li>}  </li>
<li></li>
<li>return result;  </li>
<li>}  </li>
<li></li>
<li>// 判断anotherLoader是否是oneLoader的child  </li>
<li>private boolean isChild(ClassLoader oneLoader, ClassLoader anotherLoader){  </li>
<li>//…  </li>
<li>}  </li>
<li></li>
<li>// … more methods   </li>
<li>}<br>　　决定应该使用何种类加载器的接口是IClassLoaderStrategy，为了帮助IClassLoadStrategy做决定，给它传递了个ClassLoadContext对象作为参数。ClassLoadContext持有要加载的类。</li>
</ol>
<p>　　上面代码的逻辑很简单：如调用类的当前类加载器和上下文类加载器是父子关系，则总是选择子类加载器。对子类加载器可见的资源通常是对父类可见资源的超集，因此如果每个开发者都遵循J2SE的代理规则，这样做大多数情况下是合适的。</p>
<p>　　当前类加载器和上下文类加载器是兄弟关系时，决定使用哪一个是比较困难的。理想情况下，Java运行时不应产生这种模糊。但一旦发生，上面代码选择上下文类加载器。这是作者本人的实际经验，绝大多数情况下应该能正常工作。你可以修改这部分代码来适应具体需要。<br>一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程。</p>
<p>　　最后需要检查一下，以便保证所选类加载器不是系统类加载器的父亲，在开发标准扩展类库时这通常是个好习惯。</p>
<p>　　注意作者故意没有检查要加载资源或类的名称。Java XML API成为J2SE核心的历程应该能让我们清楚过滤类名并不是好想法。作者也没有试图检查哪个类加载器加载首先成功，而是检查类加载器的父子关系，这是更好更有保证的方法。</p>
<p>　　下面是类加载器的选择器：<br>[java] view plain copy</p>
<ol>
<li>package classloader.context;  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>类加载解析器，获取最合适的类加载器 </li>
</ul>
</li>
<li>*/  </li>
<li>public abstract class ClassLoaderResolver {  </li>
<li></li>
<li>private static IClassLoadStrategy s_strategy;  // initialized in <clinit>  </clinit></li>
<li>private static final int CALL_CONTEXT_OFFSET = 3;  // may need to change if this class is redesigned  </li>
<li>private static final CallerResolver CALLER_RESOLVER;  // set in <clinit>  </clinit></li>
<li></li>
<li>static {  </li>
<li>try {  </li>
<li>// This can fail if the current SecurityManager does not allow  </li>
<li>// RuntimePermission (“createSecurityManager”):  </li>
<li>CALLER_RESOLVER = new CallerResolver();  </li>
<li>} catch (SecurityException se) {  </li>
<li>throw new RuntimeException(“ClassLoaderResolver: could not create CallerResolver: “ + se);  </li>
<li>}  </li>
<li>s_strategy = new DefaultClassLoadStrategy();  //默认使用缺省加载策略  </li>
<li>}  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>This method selects the best classloader instance to be used for </li>
</ul>
</li>
<li><ul>
<li>class/resource loading by whoever calls this method. The decision </li>
</ul>
</li>
<li><ul>
<li>typically involves choosing between the caller’s current, thread context, </li>
</ul>
</li>
<li><ul>
<li>system, and other classloaders in the JVM and is made by the {@link IClassLoadStrategy} </li>
</ul>
</li>
<li><ul>
<li>instance established by the last call to {@link #setStrategy}. </li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li>@return classloader to be used by the caller [‘null’ indicates the </li>
</ul>
</li>
<li><ul>
<li>primordial loader] </li>
</ul>
</li>
<li>*/  </li>
<li>public static synchronized ClassLoader getClassLoader() {  </li>
<li>final Class caller = getCallerClass(0); // 获取执行当前方法的类  </li>
<li>final ClassLoadContext ctx = new ClassLoadContext(caller);  // 创建类加载上下文  </li>
<li>return s_strategy.getClassLoader(ctx);  // 获取最合适的类加载器  </li>
<li>}  </li>
<li></li>
<li>public static synchronized IClassLoadStrategy getStrategy() {  </li>
<li>return s_strategy;  </li>
<li>}  </li>
<li></li>
<li>public static synchronized IClassLoadStrategy setStrategy(final IClassLoadStrategy strategy) {  </li>
<li>final IClassLoadStrategy old = s_strategy;  // 设置类加载策略  </li>
<li>s_strategy = strategy;  </li>
<li>return old;  </li>
<li>}  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>A helper class to get the call context. It subclasses SecurityManager </li>
</ul>
</li>
<li><ul>
<li>to make getClassContext() accessible. An instance of CallerResolver </li>
</ul>
</li>
<li><ul>
<li>only needs to be created, not installed as an actual security manager. </li>
</ul>
</li>
<li>*/  </li>
<li>private static final class CallerResolver extends SecurityManager {  </li>
<li>@Override  </li>
<li>protected Class[] getClassContext() {  </li>
<li>return super.getClassContext();  // 获取当执行栈的所有类，native方法  </li>
<li>}  </li>
<li></li>
<li>}  </li>
<li></li>
<li>/* </li>
<li><ul>
<li>Indexes into the current method call context with a given </li>
</ul>
</li>
<li><ul>
<li>offset. </li>
</ul>
</li>
<li>*/  </li>
<li>private static Class getCallerClass(final int callerOffset) {  </li>
<li>return CALLER_RESOLVER.getClassContext()[CALL_CONTEXT_OFFSET  </li>
<li><ul>
<li>callerOffset];  // 获取执行栈上某个方法所属的类  </li>
</ul>
</li>
<li>}  </li>
<li>}<br>　　可通过调用ClassLoaderResolver.getClassLoader()方法来获取类加载器对象，并使用其ClassLoader的接口如loadClass()等来加载类和资源。此外还可使用下面的ResourceLoader接口来取代ClassLoader接口：</li>
</ol>
<p>[java] view plain copy</p>
<ol>
<li>package classloader.context;  </li>
<li></li>
<li>import java.net.URL;  </li>
<li></li>
<li>public class ResourceLoader {  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>加载一个类 </li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li>@param name </li>
</ul>
</li>
<li><ul>
<li>@return  </li>
</ul>
</li>
<li><ul>
<li>@throws java.lang.ClassNotFoundException  </li>
</ul>
</li>
<li><ul>
<li>@see java.lang.ClassLoader#loadClass(java.lang.String) </li>
</ul>
</li>
<li>*/  </li>
<li>public static Class&lt;?&gt; loadClass(final String name) throws ClassNotFoundException {  </li>
<li>//获取最合适的类加载器  </li>
<li>final ClassLoader loader = ClassLoaderResolver.getClassLoader();  </li>
<li>//用指定加载器加载类  </li>
<li>return Class.forName(name, false, loader);  </li>
<li>}  </li>
<li></li>
<li>/** </li>
<li><ul>
<li>加载一个资源 </li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li>@param name </li>
</ul>
</li>
<li><ul>
<li>@return  </li>
</ul>
</li>
<li><ul>
<li>@see java.lang.ClassLoader#getResource(java.lang.String) </li>
</ul>
</li>
<li>*/  </li>
<li>public static URL getResource(final String name) {  </li>
<li>//获取最合适的类加载器  </li>
<li>final ClassLoader loader = ClassLoaderResolver.getClassLoader();  </li>
<li>//查找指定的资源  </li>
<li>if (loader != null) {  </li>
<li>return loader.getResource(name);  </li>
<li>} else {  </li>
<li>return ClassLoader.getSystemResource(name);  </li>
<li>}  </li>
<li>}  </li>
<li></li>
<li>// … more methods …  </li>
<li>}<br>　　ClassLoadContext.getCallerClass()返回的类在ClassLoaderResolver或ResourceLoader使用，这样做的目的是让其能找到调用类的类加载器（上下文加载器总是能通过Thread.currentThread().getContextClassLoader()来获得）。注意调用类是静态获得的，因此这个接口不需现有业务方法增加额外的Class参数，而且也适合于静态方法和类初始化代码。具体使用时，可以往这个上下文对象中添加具体部署环境中所需的其他属性。</li>
</ol>
<p>3 类加载器与Web容器</p>
<p>　　对于运行在 Java EE容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p>
<p>　　绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p>
<p>　　（1）每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。</p>
<p>　　（2）多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</p>
<p>　　（3）当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</p>
<p>4 类加载器与OSGi</p>
<p>　　OSGi是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse就是基于OSGi 技术来构建的。</p>
<p>　　OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 org.osgi.framework.bootdelegation的值即可。</p>
<p>　　假设有两个模块 bundleA 和 bundleB，它们都有自己对应的类加载器 classLoaderA 和 classLoaderB。在 bundleA 中包含类 com.bundleA.Sample，并且该类被声明为导出的，也就是说可以被其它模块所使用的。bundleB 声明了导入 bundleA 提供的类 com.bundleA.Sample，并包含一个类 com.bundleB.NewSample继承自 com.bundleA.Sample。在 bundleB 启动的时候，其类加载器 classLoaderB 需要加载类 com.bundleB.NewSample，进而需要加载类 com.bundleA.Sample。由于 bundleB 声明了类 com.bundleA.Sample是导入的，classLoaderB 把加载类 com.bundleA.Sample的工作代理给导出该类的 bundleA 的类加载器 classLoaderA。classLoaderA 在其模块内部查找类 com.bundleA.Sample并定义它，所得到的类 com.bundleA.Sample实例就可以被所有声明导入了此类的模块使用。对于以 java开头的类，都是由父类加载器来加载的。如果声明了系统属性 org.osgi.framework.bootdelegation=com.example.core.*，那么对于包 com.example.core中的类，都是由父类加载器来完成的。</p>
<p>　　OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议：</p>
<p>　　（1）如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。</p>
<p>　　（2）如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。</p>
<p>　　（3）如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过 Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。</p>
<p>总结</p>
<p>　　类加载器是 Java 语言的一个创新。它使得动态安装和更新软件组件成为可能。本文详细介绍了类加载器的相关话题，包括基本概念、代理模式、线程上下文类加载器、与 Web 容器和 OSGi 的关系等。开发人员在遇到 ClassNotFoundException和 NoClassDefFoundError等异常的时候，应该检查抛出异常的类的类加载器和当前线程的上下文类加载器，从中可以发现问题的所在。在开发自己的类加载器的时候，需要注意与已有的类加载器组织结构的协调。</p>
<p>参考文献：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/</a></p>
<p><a href="http://www.blogjava.net/lihao336/archive/2009/09/17/295489.html" target="_blank" rel="external">http://www.blogjava.net/lihao336/archive/2009/09/17/295489.html</a></p>
<p><a href="http://kenwublog.com/structure-of-java-class-loader" target="_blank" rel="external">http://kenwublog.com/structure-of-java-class-loader</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/07/25/Java类加载机制原理解析/" data-id="cjcw62374003a88jd4aovih6o" class="article-share-link" data-share="baidu" data-title="Java类加载机制原理解析">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM相关/">JVM相关</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/01/秒杀系统解决方案/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          秒杀系统解决方案
        
      </div>
    </a>
  
  
    <a href="/2017/07/20/Java类加载机制常见问题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Java类加载机制常见问题</div>
    </a>
  
</nav>

  



</article>



</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM相关/">JVM相关</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java容器相关/">Java容器相关</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/个人开源项目/">个人开源项目</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式消息/">分布式消息</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式缓存/">分布式缓存</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发相关/">并发相关</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感悟/">感悟</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作记录/">操作记录</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架相关/">框架相关</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发方案/">高并发方案</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM相关/" style="font-size: 18.33px;">JVM相关</a> <a href="/tags/Java基础/" style="font-size: 13.33px;">Java基础</a> <a href="/tags/Java容器相关/" style="font-size: 16.67px;">Java容器相关</a> <a href="/tags/个人开源项目/" style="font-size: 11.67px;">个人开源项目</a> <a href="/tags/分布式消息/" style="font-size: 11.67px;">分布式消息</a> <a href="/tags/分布式缓存/" style="font-size: 20px;">分布式缓存</a> <a href="/tags/并发相关/" style="font-size: 15px;">并发相关</a> <a href="/tags/感悟/" style="font-size: 10px;">感悟</a> <a href="/tags/操作记录/" style="font-size: 13.33px;">操作记录</a> <a href="/tags/框架相关/" style="font-size: 13.33px;">框架相关</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a> <a href="/tags/高并发方案/" style="font-size: 15px;">高并发方案</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/19/读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地/">读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地</a>
          </li>
        
          <li>
            <a href="/2017/09/18/读内藤树作品《青年们，读马克思吧》/">读内藤树作品《青年们，读马克思吧》</a>
          </li>
        
          <li>
            <a href="/2017/09/18/一个97年的IT人创业历程中的总结和感悟/">一个97年的IT人创业历程中的总结和感悟</a>
          </li>
        
          <li>
            <a href="/2017/08/18/分布式事务通用解决方案/">分布式事务通用解决方案</a>
          </li>
        
          <li>
            <a href="/2017/08/17/创业一段时间的总结和感悟/">创业感悟</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/yuaman" target="_blank">我的git同性交友主页</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  



  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 yutinglin<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>



</footer>


  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->









</div>
</body>
</html>
