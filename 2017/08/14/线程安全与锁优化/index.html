
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="baidu-site-verification" content="LHYPl19xg9" />
<meta name="google-site-verification" content="s5HGo7JQp9QFcl2HIOHaNDUdwj3_kdgi5nPkB5bfMHs" />
  
  <title>线程安全与锁优化——深入理解JVM阅读笔记 | 无题</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我根据我的理解把一些关键的要点整理了出来，并对其中一些内容作了删改。恳请原作者见谅。这是原文的地址：http://www.cnblogs.com/pacoson/p/5351355.html请大家多多支持原作者，感谢原作者的认真和辛勤整理。因为没有看到联系方式，不能深入交流，非常遗憾。">
<meta name="keywords" content="JVM相关">
<meta property="og:type" content="article">
<meta property="og:title" content="线程安全与锁优化——深入理解JVM阅读笔记">
<meta property="og:url" content="http://yoursite.com/2017/08/14/线程安全与锁优化/index.html">
<meta property="og:site_name" content="无题">
<meta property="og:description" content="我根据我的理解把一些关键的要点整理了出来，并对其中一些内容作了删改。恳请原作者见谅。这是原文的地址：http://www.cnblogs.com/pacoson/p/5351355.html请大家多多支持原作者，感谢原作者的认真和辛勤整理。因为没有看到联系方式，不能深入交流，非常遗憾。">
<meta property="og:updated_time" content="2017-08-15T07:56:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程安全与锁优化——深入理解JVM阅读笔记">
<meta name="twitter:description" content="我根据我的理解把一些关键的要点整理了出来，并对其中一些内容作了删改。恳请原作者见谅。这是原文的地址：http://www.cnblogs.com/pacoson/p/5351355.html请大家多多支持原作者，感谢原作者的认真和辛勤整理。因为没有看到联系方式，不能深入交流，非常遗憾。">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">无题</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天南地北问乾坤</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-线程安全与锁优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/线程安全与锁优化/" class="article-date">
  <time datetime="2017-08-14T06:44:54.000Z" itemprop="datePublished">2017-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      线程安全与锁优化——深入理解JVM阅读笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="我根据我的理解把一些关键的要点整理了出来，并对其中一些内容作了删改。恳请原作者见谅。"><a href="#我根据我的理解把一些关键的要点整理了出来，并对其中一些内容作了删改。恳请原作者见谅。" class="headerlink" title="我根据我的理解把一些关键的要点整理了出来，并对其中一些内容作了删改。恳请原作者见谅。"></a>我根据我的理解把一些关键的要点整理了出来，并对其中一些内容作了删改。恳请原作者见谅。</h5><h5 id="这是原文的地址：http-www-cnblogs-com-pacoson-p-5351355-html"><a href="#这是原文的地址：http-www-cnblogs-com-pacoson-p-5351355-html" class="headerlink" title="这是原文的地址：http://www.cnblogs.com/pacoson/p/5351355.html"></a>这是原文的地址：<a href="http://www.cnblogs.com/pacoson/p/5351355.html" target="_blank" rel="external">http://www.cnblogs.com/pacoson/p/5351355.html</a></h5><h5 id="请大家多多支持原作者，感谢原作者的认真和辛勤整理。因为没有看到联系方式，不能深入交流，非常遗憾。"><a href="#请大家多多支持原作者，感谢原作者的认真和辛勤整理。因为没有看到联系方式，不能深入交流，非常遗憾。" class="headerlink" title="请大家多多支持原作者，感谢原作者的认真和辛勤整理。因为没有看到联系方式，不能深入交流，非常遗憾。"></a>请大家多多支持原作者，感谢原作者的认真和辛勤整理。因为没有看到联系方式，不能深入交流，非常遗憾。</h5><a id="more"></a>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>1.线程安全的实现：<br>1）互斥同步（阻塞同步） 悲观的并发策略：sysncronised reentrantlock重入锁<br>2）非阻塞同步 基于冲突检测的乐观并发策略 实现了cas机制的原子类atomicInteger</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>【0】README</p>
<p>0.1）本文部分文字转自“深入理解jvm”， 旨在学习 线程安全与锁优化 的基础知识；</p>
<p>0.2）本文知识对于理解 java并发编程非常有用，个人觉得，所以我总结的很详细；</p>
<p>【1】概述</p>
<p>###【2】线程安全</p>
<h4 id="线程安全定义："><a href="#线程安全定义：" class="headerlink" title="线程安全定义："></a>线程安全定义：</h4><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的；（干货——线程安全定义） </p>
<p>####【2.1】java 语言中的线程安全（干货——java中各种操作共享的数据分为以下5类）<br>0）java中各种操作共享的数据分为以下5类：不可变， 绝对线程安全， 相对线程安全，线程兼容，线程对立；</p>
<h5 id="1）不可变对象："><a href="#1）不可变对象：" class="headerlink" title="1）不可变对象："></a>1）不可变对象：</h5><p>该对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要采取任何的线程安全保障措施；</p>
<p>1.1）如果共享数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的；</p>
<p>1.2）不妨想想java.lang.String类的对象：它是一个典型的不可变对象，调用它的substring(), replace(), concat() 这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象；</p>
<p>1.3）看个荔枝：如java.lang.Integer 构造函数所示的，将value定义为final 来保障状态不变；</p>
<h5 id="2）绝对线程安全"><a href="#2）绝对线程安全" class="headerlink" title="2）绝对线程安全"></a>2）绝对线程安全</h5><p>2.1）在java API中标注自己是线程安全的类，大多数都不是绝对的线程安全</p>
<p>2.2）java.util.Vector 是一个线程安全的容器，因为它的add()方法，get()方法，size() 方法 这些方法都是被 synchronized修饰的，尽管效率低下，但确实是安全的；对Vector的测试如下： </p>
<p>复制代码<br>// 对线程安全的容器 Vector的测试</p>
<pre><code>        public class VectorTest {
                private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); 

public static void main(String[] args) {
    while(true) {
        for (int i = 0; i &lt; 100; i++) {
            vector.add(i);
        }

        Thread removeThread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &lt; vector.size(); i++) {
                    vector.remove(i);
                }
            }
        });

        Thread printThread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i &lt; vector.size(); i++) {
                    System.out.println(vector.get(i));
                }
            }
        });

        removeThread.start();
        printThread.start();

        // 不要同时产生过多的线程，否则会导致os 假死
        while(Thread.activeCount() &gt; 20);
    }
}
}
</code></pre><blockquote>
<p>对以上代码的分析（Analysis）：</p>
<p>A1）运行结果： 作者说会抛出异常（但我的运行结果却没有抛出异常），按理说应该是会抛出异常的；</p>
<p>A2）抛出异常的原因：因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i 已经不再可用的话，再用i 访问数组就会抛出一个 ArrayIndexOutOfBoundsException。</p>
<p>A3）如果要保证这段代码能够正确执行下去，修改后的代码为：</p>
</blockquote>
<p>// 对线程安全的容器 Vector的测试(修改后的代码)</p>
<pre><code>public class ModifiedVectorTest {
private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); 

public static void main(String[] args) {
    while(true) {
        for (int i = 0; i &lt; 100; i++) {
            vector.add(i);
        }

        Thread removeThread = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (vector) { // 添加同步块，this line
                    for (int i = 0; i &lt; vector.size(); i++) {
                        vector.remove(i);
                    }
                }
            }
        });

        Thread printThread = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (vector) { // 添加同步块，this line
                    for (int i = 0; i &lt; vector.size(); i++) {
                        System.out.println(vector.get(i));
                    }
                }
            }
        });

        removeThread.start();
        printThread.start();

        // 不要同时产生过多的线程，否则会导致os 假死
        while(Thread.activeCount() &gt; 20);
    }
}
}
</code></pre><h5 id="3）相对线程安全"><a href="#3）相对线程安全" class="headerlink" title="3）相对线程安全"></a>3）相对线程安全</h5><p>3.1）上述 VectorTest.java 和 ModifiedVectorTest.java 就是相对线程安全的案例；</p>
<h5 id="4）线程兼容"><a href="#4）线程兼容" class="headerlink" title="4）线程兼容"></a>4）线程兼容</h5><p>4.1）线程兼容定义：</p>
<p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；</p>
<h5 id="5）线程对立"><a href="#5）线程对立" class="headerlink" title="5）线程对立"></a>5）线程对立</h5><p>5.1）线程对立定义：指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码；</p>
<p>5.2）由于java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常是有害的，应当尽量避免；</p>
<p>5.3）线程对立的荔枝：Thread类的suspend() 和 resume() 方法；如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。正由于这个原因，suspend和result方法已经被JDK废弃了了（@Deprecated）</p>
<p>###【2.2】线程安全的实现方法<br>1）互斥同步</p>
<p>1.1）互斥同步：是常见的并发正确性保障手段；</p>
<p>1.2）同步：是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻被一个线程使用。</p>
<p>1.3）互斥：互斥是实现同步的一种手段；临界区，互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的；</p>
<p>1.4）最基本的互斥同步手段就是 synchronized关键字：synchronized关键字经过 编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这个两个字节码指令，这两个字节码都需要一个 reference类型的参数来指明要锁定和解锁的对象；如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据 synchronized修饰的实例方法还是类方法，去取对应的对象实例或Class 对象来作为锁对象；（干货——最基本的互斥同步手段就是 synchronized关键字）</p>
<p>1.5）根据虚拟机规范的要求：在执行monitorenter指令时，如果这个对象没有锁定或当前线程已经拥有了那个对象的锁，锁的计数器加1，相应的，在执行 monitorexit 指令时会将锁计数器减1；当计数器为0时，锁就被释放了；（干货——执行monitorenter和monitorexit 指令）</p>
<p>Attention）对于monitorenter 和 monitorexit 的行为描述中，有两点需要注意：<br>A1）synchronized同步块对同一条线程来说是可重入的， 不会出现自己把自己锁死的问题；<br>A2）同步块在已进入的线程执行完之前，会阻塞后面其他线程 的进入；</p>
<p>1.6）除了synchronized之外，还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步；（干货——引入重入锁进行同步）</p>
<p>1.6.1）synchronized 和 ReentrantLock 的区别： 一个表现为 API 层面的互斥锁（lock() 和 unlock() 方法配合 try/finally 语句块来完成），另一个表现为 原生语法层面的互斥锁；</p>
<p>1.6.2）ReentrantLock增加了一些高级功能：主要有3项：等待可中断，可实现公平锁， 以及锁可以绑定多个条件；（干货——ReentrantLock 增加了3项高级功能）</p>
<p>case1）等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助；</p>
<p>case2）公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；</p>
<p>case3）锁绑定多个条件：指一个 ReentrantLock对象可以同时绑定多个 Condition对象，而在 synchronized中，锁对象的wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock 则无需这样做，只需要多次调用 newCondition() 方法即可；（干货——可重入锁ReentrantLock 和 synchronized 绑定多个条件的实现方式的区别）</p>
<p>1.6.3）关于synchronized 和 ReentrantLock 性能的分析：</p>
<p>对上图的分析（Analysis）：</p>
<p>A1）多线程环境下 synchronized的吞吐量下降得非常严重，而 ReentrantLock 则能基本保持在同一个比较稳定的水平上；与其说ReentrantLock性能好，还不如说 synchronized还有非常大的优化余地；</p>
<p>A2）虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized，所以还是提倡在 synchronized能实现需求的情况下，优先考虑使用 synchronized 来进行同步；（干货——同步方式推荐使用synchronized）</p>
<p>2）非阻塞同步<br>2.1）阻塞同步（互斥同步）的问题：就是进行线程阻塞和唤醒所带来的性能问题，互斥同步属于一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁，用户态核心态转换，维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作；（干货——阻塞同步（互斥同步）的问题）</p>
<p>2.2）非阻塞同步定义：基于冲突检测的乐观并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施，这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为 非阻塞同步；（干货——非阻塞同步定义）</p>
<p>2.3）为什么作者要说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？因为 我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？<br>2.3.1）硬件：保证一个从语义上看起来需要多次操作的行为只通过一次处理器指令就能完成，这类指令常用的有：（instructions）<br>i1）测试并设置（Test-and-Set）；<br>i2）获取并增加（Fetch-and-Increment）；<br>i3）交换（Swap）；<br>i4）比较并交换（Compare-and-Swap，下文简称 CAS）；<br>i5）加载链接/ 条件存储（Load-Linked/Store-Conditional，下文简称 LL/SC）；<br>2.4）如何使用CAS 操作来避免阻塞同步，看个荔枝：（测试incrementAndGet 方法的原子性）</p>
<p>// Atomic 变量自增运算测试(incrementAndGet 方法的原子性)</p>
<pre><code>public class AtomicTest {
public static AtomicInteger race = new AtomicInteger(0);

public static void increase() {
    // 输出正确结果，一切都要归功于 incrementAndGet 方法的原子性
    race.incrementAndGet();  
}

public static final int THREADS_COUNT = 20;

public static void main(String[] args) throws Exception {
    Thread[] threads = new Thread[THREADS_COUNT];
    for (int i = 0; i &lt; threads.length; i++) {
        threads[i] = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int j = 0; j &lt; 10000; j++) {
                    increase();
                }
            }
        });
        threads[i].start();
    }

    while(Thread.activeCount() &gt; 1) {
        Thread.yield();
    }

    System.out.println(race);
}

/**
 * incrementAndGet() 方法的JDK 源码
 * Atomically increment by one the current value.
 * @return the updated value
 */
public final int incrementAndGet() {
    for(;;) {
        int current = get();
        int next = current + 1;
        if(compareAndSet(current,next)) {
            return next;
        }
    }
}
</code></pre><p>}</p>
<p>2.5）CAS操作（比较并交换操作）的ABA问题：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就说它的值没有被其他线程改变过了吗？ 如果在这段期间它的值曾经被改为了B，之后又改回了A，那CAS操作就会误认为它从来没有被改变过，这个漏洞称为 CAS操作的 ABA问题；</p>
<p>2.6）解决方法：J.U.C 包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的version 来保证CAS的正确性。不过目前来说这个类比较鸡肋， 大部分cases 下 ABA问题 不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效；（干货——CAS操作（比较并交换操作）的ABA问题及其解决方法） </p>
<p>3）无同步方案<br>3.0）intro： 如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的；下面介绍两类线程安全代码：</p>
<p>3.1）第一类线程安全代码——可重入代码：也叫作纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误； （干货——可重入代码定义）<br>3.1.1）所有的可重入代码都是线程安全的；</p>
<p>3.1.2）如何判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的；</p>
<p>3.2）第二类线程安全代码——线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能够保证在同一线程中执行？ 如果能保证，我们就可以把共享数据的可见范围限制在同一个线程内，这样，无需同步也可以保证线程间不出现数据争用问题；</p>
<p>【3】锁优化<br>【3.1】 自旋锁与自适应自旋（干货——引入自旋锁与自适应自旋）<br>1）problem：前文中我们提到，互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程很不值得；（干货——产生自旋锁与自适应自旋的背景）</p>
<p>2）自旋锁定义：为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁；（solution）</p>
<p>2.1）jdk1.6中 自旋锁是默认开启的，可以使用 -XX:+UseSpinning 参数来开启；</p>
<p>2.2）自旋等待的时间必须要有一定的限度： 如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10，用户可以用参数 -XX:PreBlockSpin 来更改；</p>
<p>2.3）自适应自旋锁：jdk1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定；</p>
<p>case1）如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个cycle；</p>
<p>case2）如果对于某个锁，自旋很少成功获得过， 那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源；</p>
<p>【3.2】锁消除<br>1）定义：锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检查到不可能存在共享数据竞争的锁进行消除；（干货——引入锁消除的概念）</p>
<p>2）锁消除的主要判定依据：来源于逃逸分析的数据支持；如果判定在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行了；</p>
<p>3）problem+solution</p>
<p>3.1）problem：程序员自己应该很清楚，怎么会在明知道不存在数据争用的case下还要求同步呢？</p>
<p>3.2）solution：许多同步措施并不是程序员自己加入的，同步的代码在java程序中的普遍程度早就超过了大部分人的想象；（干货——许多同步措施并不是程序员自己加入的）</p>
<p>3.3）看个荔枝：这段code 仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步；（干货——锁消除的荔枝）</p>
<pre><code>public class LockEliminateTest {

// raw code
public String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}

// javac 转化后的字符串连接操作
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
</code></pre><p>}</p>
<p> 对以上代码的分析（Analysis）：</p>
<p>A1）对于 javac 转化后的字符串连接操作代码： 使用了同步，因为StringBuffer.append() 方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，很快就会发现他的动态作用域被限制在 concatString() 方法内部；也就是所 sb 的所有引用都不会逃逸到方法之外；</p>
<p>A2）所以，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了；</p>
<p>【3.3】锁粗化<br>1）problem：如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗；</p>
<p>2）锁粗化的定义：如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部；</p>
<p>3）看个荔枝：以下面的代码为例，就是扩展到第一个 append() 操作前直到最后一个 append()操作之后，这样只需要加锁一次就可以了； </p>
<p>// javac 转化后的字符串连接操作</p>
<pre><code>public String concatString(String s1, String s2, String s3) {
StringBuffer sb = new StringBuffer();
sb.append(s1);
    sb.append(s2);
sb.append(s3);
return sb.toString();
}
</code></pre><p>【3.4】轻量级锁<br>1）重量级锁定义：使用操作系统互斥量来实现的传统锁；<br>2）轻量级锁的目的：是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗；（干货——轻量级锁的作用）<br>3）HotSpot虚拟机的对象头分为两部分信息：（干货——HotSpot虚拟机的对象头分为两部分信息）<br>3.1）第一部分：用于存储对象自身的运行时数据，如哈希码，GC分代年龄等；这部分数据的长度在32位和64位的虚拟机中分别为 32bit 和 64bit，官方称它为 Mark Word，它是实现轻量级锁和偏向锁的关键；（干货——Mark Word 是实现轻量级锁和偏向锁的关键）<br>3.2）第二部分：用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度；<br>3.3）对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会工具对象的状态复用自己的存储空间；<br>3.4）HotSpot 虚拟机对象头Mark Word 如下图所示：</p>
<p>4）在代码进入同步块的时候：<br>4.1）轻量级锁的加锁过程：（干货——轻量级锁的加锁过程）</p>
<p>step1）如果此同步对象没有被锁定（锁标志位为01状态）：虚拟机首先将在当前线程的栈帧中建立一个名为 锁记录的空间，用于存储对象目前的Mark Word 的拷贝；</p>
<p>step2）然后，虚拟机将使用CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record的指针；</p>
<p>step3）如果这个更新工作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为 00，即表示 此对象处于轻量级锁定状态；</p>
<p>step4）如果这个更新失败了，虚拟机首先会检查对象的Mark Word 是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象以及被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为 10，Mark Word中存储的就是指向重量级（互斥量）的指针，后面等待锁的线程也要进入阻塞状态；</p>
<p>4.2）轻量级锁的解锁过程：（干货——轻量级锁的解锁过程，其解锁过程也是通过CAS 操作来进行的）</p>
<p>step1）如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS 操作把对象当前的Mark Word 和 线程中复制的 Dispatched Mard Word替换回来；</p>
<p>step2）如果替换成功，整个同步过程就over了；</p>
<p>step3）如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程；<br>Conclusion）</p>
<p>C1）轻量级锁能提升程序同步性能的依据是： 对于绝大部分的锁，在整个同步周期内都是不存在竞争的；</p>
<p>C2）如果没有竞争，轻量级锁使用CAS 操作避免了使用互斥量的开销；但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS 操作，因此在有竞争的case下， 轻量级锁会比传统的重量级锁更慢；</p>
<p>【3.5】偏向锁</p>
<p>1）偏向锁的目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能；</p>
<p>2）如果说轻量级锁是在无竞争的情况使用CAS 操作去消除同步使用的互斥量：那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS 操作都不做了；（干货——偏向锁的定义）</p>
<p>3）偏向锁的偏： 它的意思是这个锁会偏向于 第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步；</p>
<p>4）偏向锁的原理：若当前虚拟机启用了偏向锁，那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为01， 即偏向模式；同时使用CAS 操作把获取到这个锁的线程的ID 记录在对象的 Mark Word之中，如果 CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；（干货——偏向锁的原理）</p>
<p>5）当有另一个线程去尝试获取这个锁时，偏向模式就结束了：根据锁对象目前是否处于被锁定的状态， 撤销偏向后恢复到未锁定（标志位为01）或轻量级锁定（标志位为00）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；</p>
<p>Conclusion）<br>C1）偏向锁可以提高带有同步但无竞争的程序性能；<br>C2）如果程序中大多数的锁总是被多个不同的线程访问：那偏向模式是多余的；</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2017/08/14/线程安全与锁优化/" data-id="cj6sssb8g002izpservsvzqiv" class="article-share-link" data-share="baidu" data-title="线程安全与锁优化——深入理解JVM阅读笔记">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM相关/">JVM相关</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/17/创业一段时间的总结和感悟/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          创业一段时间的总结和感悟：
        
      </div>
    </a>
  
  
    <a href="/2017/08/13/Java并发编程：volatile关键字解析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Java并发编程：volatile关键字解析</div>
    </a>
  
</nav>

  



</article>



</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM相关/">JVM相关</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java容器相关/">Java容器相关</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/个人开源项目/">个人开源项目</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式消息/">分布式消息</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式缓存/">分布式缓存</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发相关/">并发相关</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作记录/">操作记录</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架相关/">框架相关</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发方案/">高并发方案</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM相关/" style="font-size: 18.33px;">JVM相关</a> <a href="/tags/Java基础/" style="font-size: 11.67px;">Java基础</a> <a href="/tags/Java容器相关/" style="font-size: 16.67px;">Java容器相关</a> <a href="/tags/个人开源项目/" style="font-size: 10px;">个人开源项目</a> <a href="/tags/分布式消息/" style="font-size: 10px;">分布式消息</a> <a href="/tags/分布式缓存/" style="font-size: 20px;">分布式缓存</a> <a href="/tags/并发相关/" style="font-size: 15px;">并发相关</a> <a href="/tags/操作记录/" style="font-size: 11.67px;">操作记录</a> <a href="/tags/框架相关/" style="font-size: 11.67px;">框架相关</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a> <a href="/tags/高并发方案/" style="font-size: 10px;">高并发方案</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/17/创业一段时间的总结和感悟/">创业一段时间的总结和感悟：</a>
          </li>
        
          <li>
            <a href="/2017/08/14/线程安全与锁优化/">线程安全与锁优化——深入理解JVM阅读笔记</a>
          </li>
        
          <li>
            <a href="/2017/08/13/Java并发编程：volatile关键字解析/">Java并发编程：volatile关键字解析</a>
          </li>
        
          <li>
            <a href="/2017/08/12/我为什么离开学校——十六岁那一年/">我为什么离开学校——十六岁那一年</a>
          </li>
        
          <li>
            <a href="/2017/08/11/事务的四大特性以及事务的四种隔离级别/">事务的四大特性以及事务的四种隔离级别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/yuaman" target="_blank">我的git同性交友主页</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  



  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 yutinglin<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>



</footer>


  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->









</div>
</body>
</html>
