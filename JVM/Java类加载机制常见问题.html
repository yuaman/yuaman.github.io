<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java类加载机制常见问题 | 无题</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java类加载机制常见问题</h1><a id="logo" href="/.">无题</a><p class="description"></p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a class="current" href="/JVM/"><i class="fa fa-archive"> JVM</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java类加载机制常见问题</h1><div class="post-content"><p>Java类加载机制常见问题梳理<br><a id="more"></a> </p>
<h2 id="什么是类加载："><a href="#什么是类加载：" class="headerlink" title="什么是类加载："></a>什么是类加载：</h2><p>概念：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验–转换解析–初始化，最终形成能被java虚拟机直接使用的java类型，就是jvm的类加载机制。<br>类加载包含了以下过程：加载–验证–准备–解析–初始化–使用–卸载</p>
<h2 id="Java的类加载器都有哪些？每个类加载器都加载哪些类？"><a href="#Java的类加载器都有哪些？每个类加载器都加载哪些类？" class="headerlink" title="Java的类加载器都有哪些？每个类加载器都加载哪些类？"></a>Java的类加载器都有哪些？每个类加载器都加载哪些类？</h2><h3 id="启动（Bootstrap）类加载器："><a href="#启动（Bootstrap）类加载器：" class="headerlink" title="启动（Bootstrap）类加载器："></a>启动（Bootstrap）类加载器：</h3><p>引导类装入器是用本地代码实现的类装入器，它负责将 <java_runtime_home>/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</java_runtime_home></p>
<h3 id="扩展（Extension）类加载器："><a href="#扩展（Extension）类加载器：" class="headerlink" title="扩展（Extension）类加载器："></a>扩展（Extension）类加载器：</h3><p>扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</p>
<h3 id="系统（System）类加载器："><a href="#系统（System）类加载器：" class="headerlink" title="系统（System）类加载器："></a>系统（System）类加载器：</h3><p>系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。</p>
<h2 id="这些类加载之间的父子关系是怎样的？"><a href="#这些类加载之间的父子关系是怎样的？" class="headerlink" title="这些类加载之间的父子关系是怎样的？"></a>这些类加载之间的父子关系是怎样的？</h2><p>他们的委派关系是系统类加载器委派给扩展类加载器，扩展类加载器委派给启动类加载器<br>继承关系是系统类继承自扩展类加载器，扩展类加载器继承自url加载器和secure加载器以及classloader抽象类</p>
<h2 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h2><p>就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<h2 id="为什么Java的类加载器要使用双亲委派模型？"><a href="#为什么Java的类加载器要使用双亲委派模型？" class="headerlink" title="为什么Java的类加载器要使用双亲委派模型？"></a>为什么Java的类加载器要使用双亲委派模型？</h2><p>java类以及它的类加载器一起具备了一种带有优先级的层次关系。如 java.lang.Object(它在rt.jar之中)。</p>
<p>首先我们要知道一点，同一个类 被不同的 类加载器 加载成两个类之后，这两个类是不同的。<br>如果java.lang.Object类被不同的类加载器加载很多次，jvm中存在了多个不同的Object类，那么java类型体系中最基础的行为也无从保证，应用程序会一片混乱(we know,all the class extends from java.lang.Object,如果Object存在多个品种，那绝对是灾难)。</p>
<p>相反，使用了双亲委派模型，无论哪个类加载器去加载，都会委派到BoorStrap ClassLoader进行加载，保证了Object在各个类加载器环境中，都是同一个类。</p>
<p>再提一点双亲委派模型的工作机制，以类 A 为例，A如果以Application ClassLoader方式来加载，Application ClassLoader委派给Extension ClassLoader,再到BootStrap ClassLoader.<br>然而，BootStrap ClassLoader管理范围内(<java_home>/lib目录中 ，或-Xbootclasspath参数指定路径中的jar包)没查到类A，那么就让最初请求的类加载器，Application ClassLoader来加载</java_home></p>
<p>at last，提一点，双亲委派模型 在jvm成长史上被重大破坏过三次，但是 双亲委派模型确实不错，还是像小强一样的活了下来</p>
<h2 id="如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？"><a href="#如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？" class="headerlink" title="如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？"></a>如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？</h2><p>除了和本地实现密切相关的启动类加载器之外，包括标准扩展类加载器和系统类加载器在内的所有其他类加载器我们都可以当做自定义类加载器来对待，唯一区别是是否被虚拟机默认使用。前面的内容中已经对java.lang.ClassLoader抽象类中的几个重要的方法做了介绍，这里就简要叙述一下一般用户自定义类加载器的工作流程吧（可以结合后面问题解答一起看）</p>
<p>1、首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤<br>　　<br>2、委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，真实虚拟机中各种类加载器最终会呈现树状结构），如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤<br>　　<br>3、调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转而抛异常，终止加载过程（注意：这里的异常种类不止一种）。<br>　　<br>说明：这里说的自定义类加载器是指JDK 1.2以后版本的写法，即不覆写改变java.lang.loadClass(…)已有委派逻辑情况下。</p>
<h2 id="由不同的类加载器加载的指定类还是相同的类型吗？"><a href="#由不同的类加载器加载的指定类还是相同的类型吗？" class="headerlink" title="由不同的类加载器加载的指定类还是相同的类型吗？"></a>由不同的类加载器加载的指定类还是相同的类型吗？</h2><p>在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识，不同类加载器加载的类将被置于不同的命名空间。</p>
<p>我们可以用两个自定义类加载器去加载某自定义类型（注意不要将自定义类型的字节码放置到系统路径或者扩展路径中，否则会被系统类加载器或扩展类加载器抢先加载），然后用获取到的两个Class实例进行java.lang.Object.equals（…）判断，将会得到不相等的结果。</p>
<p>这个大家可以写两个自定义的类加载器去加载相同的自定义类型，然后做个判断；同时，可以测试加载java.*类型，然后再对比测试一下测试结果。</p>
<h2 id="在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？"><a href="#在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？" class="headerlink" title="在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？"></a>在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？</h2><p>前面讲过，在不指定父类加载器的情况下，默认采用系统类加载器。可能有人觉得不明白，现在我们来看一下JDK对应的代码实现。</p>
<h2 id="在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？-1"><a href="#在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？-1" class="headerlink" title="在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？"></a>在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？</h2><p>前面讲过，在不指定父类加载器的情况下，默认采用系统类加载器。可能有人觉得不明白，现在我们来看一下JDK对应的代码实现。众所周知，我们编写自定义的类加载器直接或者间接继承自java.lang.ClassLoader抽象类，</p>
</div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JDK探究/" style="font-size: 15px;">JDK探究</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/Spring探究/" style="font-size: 15px;">Spring探究</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/02/07/软负载中心与集中配置管理/">软负载中心与集中配置管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/25/消息中间件的设计与实践/">消息中间件的设计与实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/11/分布式系统幂等性解决方案/">分布式系统幂等性解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/19/读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地/">读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/18/读内藤树作品《青年们，读马克思吧》/">读内藤树作品《青年们，读马克思吧》</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/分布式事务通用解决方案/">分布式事务通用解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/线程安全与锁优化/">线程安全与锁优化——深入理解JVM阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/13/Java并发编程：volatile关键字解析/">Java并发编程：volatile关键字解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/事务的四大特性以及事务的四种隔离级别/">事务的四大特性以及事务的四种隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/悲观锁与乐观锁与事务/">悲观锁与乐观锁与事务</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">无题.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>