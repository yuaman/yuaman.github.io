
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="baidu-site-verification" content="LHYPl19xg9" />
<meta name="google-site-verification" content="s5HGo7JQp9QFcl2HIOHaNDUdwj3_kdgi5nPkB5bfMHs" />
  
  <title>谈谈Java中equals和==的区别和使用场景 | 无题</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="讨论一下Java中equals和==的区别，这个问题看似浅显，还是有不少情况需要注意。阅览了网上一些文章，都比较片面。在此做一下详细的整理。">
<meta name="keywords" content="Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈Java中equals和==的区别和使用场景">
<meta property="og:url" content="http://yoursite.com/2016/05/09/Java中equals与==的区别与使用场景分析/index.html">
<meta property="og:site_name" content="无题">
<meta property="og:description" content="讨论一下Java中equals和==的区别，这个问题看似浅显，还是有不少情况需要注意。阅览了网上一些文章，都比较片面。在此做一下详细的整理。">
<meta property="og:updated_time" content="2017-08-21T03:58:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谈谈Java中equals和==的区别和使用场景">
<meta name="twitter:description" content="讨论一下Java中equals和==的区别，这个问题看似浅显，还是有不少情况需要注意。阅览了网上一些文章，都比较片面。在此做一下详细的整理。">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">无题</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天南地北问乾坤</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-Java中equals与==的区别与使用场景分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/09/Java中equals与==的区别与使用场景分析/" class="article-date">
  <time datetime="2016-05-09T04:44:54.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      谈谈Java中equals和==的区别和使用场景
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>讨论一下Java中equals和==的区别，这个问题看似浅显，还是有不少情况需要注意。阅览了网上一些文章，都比较片面。在此做一下详细的整理。<br><a id="more"></a></p>
<h2 id="先直接上结论：："><a href="#先直接上结论：：" class="headerlink" title="先直接上结论：："></a>先直接上结论：：</h2><p>1.当比较对象为基本数据类型的时候，”==“比较的是二者在栈内存中的值。object默认的equals方法，是比较两个对象的引用是不是相同</p>
<p>2.当比较对象为复杂数据类型的时候，当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，比较结果为true。但string类有常量池的缘故较为特殊。</p>
<p>3.当比较对象为实体类的时候，不重写equals方法，采用object默认的equals方法，是比较两个对象的引用是不是相同。比较的是二者在堆内存中的引用地址，无意义，一般在实体类中进行重写equals方法，自定义比较规则。</p>
<h2 id="java中的数据类型，可分为两类："><a href="#java中的数据类型，可分为两类：" class="headerlink" title="java中的数据类型，可分为两类："></a>java中的数据类型，可分为两类：</h2><h3 id="1-基本数据类型，也称原始数据类型的比较。"><a href="#1-基本数据类型，也称原始数据类型的比较。" class="headerlink" title="1.基本数据类型，也称原始数据类型的比较。"></a>1.基本数据类型，也称原始数据类型的比较。</h3><p>byte,short,char,int,long,float,double,boolean<br>  他们之间的比较，应用双等号（==）,比较的是他们的值。 </p>
<p>示例：</p>
<pre><code>public class Test {

public static void main(String[] args) {  

  int i=5;  
  int j=5;  

  if(i==j) System.out.println(&quot;i和j相等！&quot;);  
  else System.out.println(&quot;不相等！&quot;);  
  }
</code></pre><blockquote>
<p>运行结果：<br>   “i和j相等！” </p>
</blockquote>
<p>因为此时比较对象为基本数据类型，所以“==”比较的是它们存放于虚拟机栈内存中的值。 </p>
<h2 id="2-复杂数据类型的比较"><a href="#2-复杂数据类型的比较" class="headerlink" title="2.复杂数据类型的比较"></a>2.复杂数据类型的比较</h2><p>在Java API中，有些类重写了equals()方法，它们的比较规则是：当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，则比较结果为true。这些类包括：String、Double、Float、Long、Integer、Short、Byte、、Boolean、BigDecimal、BigInteger等等，太多太多了，但是常见的就这些了，具体可以查看API中类的equals()方法，就知道了。</p>
<p>深入到内存中。==就是比较堆内存的值是否相等（对象地址存放在堆内存），equals（）就是比较栈内存的值（对象的值存在于栈内存）。String有个常量池。String a=”abc”;String b=”abc”;a==b是返回true的，就是因为常量池的原因，实际上a和b是同一个对象。但是String a=”abc”;String a=new String(“abc”);这样a==b就是返回flase了，a和b就不是同一个对象（他们的地址不等。）</p>
<p>原来，程序在运行的时候会创建一个字符串缓冲池当使用 s2 = “Monday” 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，s1先被放到了池中，所以在s2被创建的时候，程序找到了具有相同值的 s1<br>将s2引用s1所引用的对象”Monday”<br>第二段程序中，使用了 new 操作符，他明白的告诉程序：”我要一个新的！不要旧的！”于是一个新的”Monday”Sting对象被创建在内存中。他们的值相同，但是位置不同，一个在池中游泳一个在岸边休息。哎呀，真是资源浪费，明明是一样的非要分开做什么呢？</p>
<h3 id="3-实体类的比较"><a href="#3-实体类的比较" class="headerlink" title="3.实体类的比较"></a>3.实体类的比较</h3><p>  当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 </p>
<p>JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址。</p>
<p>对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。</p>
<p>示例：</p>
<pre><code>public class Student {  

    String name;  

        public Student(){  

    }  

    public Student(String name){  

    this.name=name;  

}                                                            

public class Test {  

    public static void main(String[] args) {  

      Student s = new Student(&quot;BlueSky&quot;);  
      Student s1=new Student(&quot;BlueSky&quot;);  

      if(s==s1)  System.out.println(&quot;s和是s1相等！&quot;);  
      else System.out.println(&quot;s和是s1不相等！&quot;);  

      if(s.equals(s1)) System.out.println(&quot;s和是s1相等！&quot;);  
      else System.out.println(&quot;s和是s1不相等！&quot;);  
}  
</code></pre><p>}  </p>
<blockquote>
<p>运行结果：<br>s和是s1不相等！<br>s和是s1不相等！</p>
</blockquote>
<p>结果验证了Object类的equals()方法用来比较是否一个对象是利用内存地址比较，所以在定义一个类的时候，如果涉及到对象的比较（通过我们要比较内容），应该重写equals()方法。重写的一般规则是：</p>
<p>1、先用“==”判断是否相等。</p>
<p>2、判断equals()方法的参数是否为null，如果为null，则返回false；因为当前对象不可能为null，如果为null，则不能调用其equals()方法，否则抛java.lang.NullPointerException异常。</p>
<p>3、当参数不为null，则如果两个对象的运行时类（通过getClass()获取）不相等，返回false，否则继续判断。</p>
<p>4、判断类的成员是否对应相等。往下就随意发挥了。呵呵！</p>
<p>我们对实体进行比较的时候往往要比较的是里面的值，所以我们为了达到这个目的，要在实体类里面重写equals()方法，进行对象里面的内容比较。如上面，我们在Student类中重写equals()方法。   </p>
<p>重写equals()方法后再次进行比较：<br> Student类：</p>
<pre><code>public class Student {  

String name;  

public Student(){  

}  

public Student(String name){  

    this.name=name;  

}  


public boolean equals(Object obj) {  
    if (this == obj)      //传入的对象就是它自己，如s.equals(s)；肯定是相等的；  
        return true;   
    if (obj == null)     //如果传入的对象是空，肯定不相等  
        return false;  
    if (getClass() != obj.getClass())  //如果不是同一个类型的，如Studnet类和Animal类，  
                                       //也不用比较了，肯定是不相等的  
        return false;  
    Student other = (Student) obj;       
    if (name == null) {  
        if (other.name != null)  
            return false;  
    } else if (!name.equals(other.name))   //如果name属性相等，则相等  
        return false;  
    return true;  
}  
</code></pre><p>}  </p>
<p>测试类Test：</p>
<pre><code>public class Test {  

public static void main(String[] args) {  

  Student s = new Student(&quot;BlueSky&quot;);  
  Student s1=new Student(&quot;BlueSky&quot;);  

  if(s.equals(s1)) System.out.println(&quot;s和是s1相等！&quot;);  
  else System.out.println(&quot;s和是s1不相等！&quot;);  
}  
</code></pre><p>}  </p>
<blockquote>
<p>运行结果：<br>“s和是s1相等！”</p>
</blockquote>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>1.当比较对象为基本数据类型的时候，”==“比较的是二者在栈内存中的值。</p>
<p>2.当比较对象为复杂数据类型的时候，当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，则比较结果为true。但string类有常量池的缘故较为特殊。</p>
<p>3.当比较对象为实体类的时候，不重写equals方法，比较的是二者在堆内存中的引用地址，无意义，一般在实体类中进行重写equals方法，自定义比较规则.</p>
<h2 id="附：Object的getClass方法与getName方法"><a href="#附：Object的getClass方法与getName方法" class="headerlink" title="附：Object的getClass方法与getName方法"></a>附：Object的getClass方法与getName方法</h2><h3 id="getClass方法："><a href="#getClass方法：" class="headerlink" title="getClass方法："></a>getClass方法：</h3><p>类型：public final Class&lt;? extends Object&gt; getClass()<br>功能：返回该对象的运行时类的Java.lang.Class对象（API上的解释）<br>有方法类型可以知道，该方法只能由类的实例变量调用<br>例子：</p>
<pre><code>[java] view plain copy
JButton b1 = new JButton(&quot;button1&quot;);  
System.out.println(b1.getClass());  
</code></pre><blockquote>
<p>输出：<br>    class javax.swing.JButton</p>
</blockquote>
<p>class属性<br>当你要获得一个类的Class对象时（作函数参数的时候），你不能调用getClass方法，那你只能用类名.class来达到效果<br>例子：</p>
<pre><code>[java] view plain copy
System.out.println(JButton.class);  
</code></pre><blockquote>
<p>输出：<br>class javax.swing.JButton</p>
</blockquote>
<h3 id="getName方法："><a href="#getName方法：" class="headerlink" title="getName方法："></a>getName方法：</h3><p>类型：public String getName()<br>功能：以String形式返回次Class对象所表示的实体名称<br>例子：</p>
<pre><code>[java] view plain copy
JButton b1 = new JButton(&quot;button1&quot;);  
System.out.println(b1.getName());  
</code></pre><blockquote>
<p>输出：<br>javax.swing.JButton</p>
</blockquote>
<p>可以发现用class属性和getClass返回的输出是一样的，用getName返回的比前面两种少了class和一个空格。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/05/09/Java中equals与==的区别与使用场景分析/" data-id="cj7mzwst50004j2732shhy32r" class="article-share-link" data-share="baidu" data-title="谈谈Java中equals和==的区别和使用场景">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础/">Java基础</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/23/SpringBoot核心原理——自动配置/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          Spring Boot核心原理－自动配置
        
      </div>
    </a>
  
  
    <a href="/2016/05/03/Rabbitmq基本原理/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Rabbitmq基本原理</div>
    </a>
  
</nav>

  



</article>



</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM相关/">JVM相关</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java容器相关/">Java容器相关</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/个人开源项目/">个人开源项目</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式消息/">分布式消息</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式缓存/">分布式缓存</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发相关/">并发相关</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作记录/">操作记录</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架相关/">框架相关</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发方案/">高并发方案</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM相关/" style="font-size: 18.33px;">JVM相关</a> <a href="/tags/Java基础/" style="font-size: 11.67px;">Java基础</a> <a href="/tags/Java容器相关/" style="font-size: 16.67px;">Java容器相关</a> <a href="/tags/个人开源项目/" style="font-size: 10px;">个人开源项目</a> <a href="/tags/分布式消息/" style="font-size: 10px;">分布式消息</a> <a href="/tags/分布式缓存/" style="font-size: 20px;">分布式缓存</a> <a href="/tags/并发相关/" style="font-size: 13.33px;">并发相关</a> <a href="/tags/操作记录/" style="font-size: 11.67px;">操作记录</a> <a href="/tags/框架相关/" style="font-size: 11.67px;">框架相关</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/高并发方案/" style="font-size: 13.33px;">高并发方案</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/30/果核儿网项目简介（架构层面）/">果核儿网电商平台简介（架构层面）</a>
          </li>
        
          <li>
            <a href="/2017/08/17/创业一段时间的总结和感悟/">创业感悟</a>
          </li>
        
          <li>
            <a href="/2017/08/14/线程安全与锁优化/">线程安全与锁优化——深入理解JVM阅读笔记</a>
          </li>
        
          <li>
            <a href="/2017/08/13/Java并发编程：volatile关键字解析/">Java并发编程：volatile关键字解析</a>
          </li>
        
          <li>
            <a href="/2017/08/12/我为什么离开学校——十六岁那一年/">我为什么离开学校——记十六岁那一年</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/yuaman" target="_blank">我的git同性交友主页</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  



  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 yutinglin<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>



</footer>


  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->









</div>
</body>
</html>
