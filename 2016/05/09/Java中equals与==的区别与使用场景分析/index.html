<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>谈谈Java中equals和==的区别和使用场景 | 无题</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">谈谈Java中equals和==的区别和使用场景</h1><a id="logo" href="/.">无题</a><p class="description"></p></div><div id="nav-menu"></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">谈谈Java中equals和==的区别和使用场景</h1><div class="post-meta">May 9, 2016</div><div class="post-content"><p>讨论一下Java中equals和==的区别，这个问题看似浅显，还是有不少情况需要注意。阅览了网上一些文章，都比较片面。在此做一下详细的整理。<br><a id="more"></a></p>
<h2 id="先直接上结论：："><a href="#先直接上结论：：" class="headerlink" title="先直接上结论：："></a>先直接上结论：：</h2><p>1.当比较对象为基本数据类型的时候，”==“比较的是二者在栈内存中的值。object默认的equals方法，是比较两个对象的引用是不是相同</p>
<p>2.当比较对象为复杂数据类型的时候，当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，比较结果为true。但string类有常量池的缘故较为特殊。</p>
<p>3.当比较对象为实体类的时候，不重写equals方法，采用object默认的equals方法，是比较两个对象的引用是不是相同。比较的是二者在堆内存中的引用地址，无意义，一般在实体类中进行重写equals方法，自定义比较规则。</p>
<h2 id="java中的数据类型，可分为两类："><a href="#java中的数据类型，可分为两类：" class="headerlink" title="java中的数据类型，可分为两类："></a>java中的数据类型，可分为两类：</h2><h3 id="1-基本数据类型，也称原始数据类型的比较。"><a href="#1-基本数据类型，也称原始数据类型的比较。" class="headerlink" title="1.基本数据类型，也称原始数据类型的比较。"></a>1.基本数据类型，也称原始数据类型的比较。</h3><p>byte,short,char,int,long,float,double,boolean<br>  他们之间的比较，应用双等号（==）,比较的是他们的值。 </p>
<p>示例：</p>
<pre><code>public class Test {

public static void main(String[] args) {  

  int i=5;  
  int j=5;  

  if(i==j) System.out.println(&quot;i和j相等！&quot;);  
  else System.out.println(&quot;不相等！&quot;);  
  }
</code></pre><blockquote>
<p>运行结果：<br>   “i和j相等！” </p>
</blockquote>
<p>因为此时比较对象为基本数据类型，所以“==”比较的是它们存放于虚拟机栈内存中的值。 </p>
<h2 id="2-复杂数据类型的比较"><a href="#2-复杂数据类型的比较" class="headerlink" title="2.复杂数据类型的比较"></a>2.复杂数据类型的比较</h2><p>在Java API中，有些类重写了equals()方法，它们的比较规则是：当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，则比较结果为true。这些类包括：String、Double、Float、Long、Integer、Short、Byte、、Boolean、BigDecimal、BigInteger等等，太多太多了，但是常见的就这些了，具体可以查看API中类的equals()方法，就知道了。</p>
<p>深入到内存中。==就是比较堆内存的值是否相等（对象地址存放在堆内存），equals（）就是比较栈内存的值（对象的值存在于栈内存）。String有个常量池。String a=”abc”;String b=”abc”;a==b是返回true的，就是因为常量池的原因，实际上a和b是同一个对象。但是String a=”abc”;String a=new String(“abc”);这样a==b就是返回flase了，a和b就不是同一个对象（他们的地址不等。）</p>
<p>原来，程序在运行的时候会创建一个字符串缓冲池当使用 s2 = “Monday” 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，s1先被放到了池中，所以在s2被创建的时候，程序找到了具有相同值的 s1<br>将s2引用s1所引用的对象”Monday”<br>第二段程序中，使用了 new 操作符，他明白的告诉程序：”我要一个新的！不要旧的！”于是一个新的”Monday”Sting对象被创建在内存中。他们的值相同，但是位置不同，一个在池中游泳一个在岸边休息。哎呀，真是资源浪费，明明是一样的非要分开做什么呢？</p>
<h3 id="3-实体类的比较"><a href="#3-实体类的比较" class="headerlink" title="3.实体类的比较"></a>3.实体类的比较</h3><p>  当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 </p>
<p>JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址。</p>
<p>对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。</p>
<p>示例：</p>
<pre><code>public class Student {  

    String name;  

        public Student(){  

    }  

    public Student(String name){  

    this.name=name;  

}                                                            

public class Test {  

    public static void main(String[] args) {  

      Student s = new Student(&quot;BlueSky&quot;);  
      Student s1=new Student(&quot;BlueSky&quot;);  

      if(s==s1)  System.out.println(&quot;s和是s1相等！&quot;);  
      else System.out.println(&quot;s和是s1不相等！&quot;);  

      if(s.equals(s1)) System.out.println(&quot;s和是s1相等！&quot;);  
      else System.out.println(&quot;s和是s1不相等！&quot;);  
}  
</code></pre><p>}  </p>
<blockquote>
<p>运行结果：<br>s和是s1不相等！<br>s和是s1不相等！</p>
</blockquote>
<p>结果验证了Object类的equals()方法用来比较是否一个对象是利用内存地址比较，所以在定义一个类的时候，如果涉及到对象的比较（通过我们要比较内容），应该重写equals()方法。重写的一般规则是：</p>
<p>1、先用“==”判断是否相等。</p>
<p>2、判断equals()方法的参数是否为null，如果为null，则返回false；因为当前对象不可能为null，如果为null，则不能调用其equals()方法，否则抛java.lang.NullPointerException异常。</p>
<p>3、当参数不为null，则如果两个对象的运行时类（通过getClass()获取）不相等，返回false，否则继续判断。</p>
<p>4、判断类的成员是否对应相等。往下就随意发挥了。呵呵！</p>
<p>我们对实体进行比较的时候往往要比较的是里面的值，所以我们为了达到这个目的，要在实体类里面重写equals()方法，进行对象里面的内容比较。如上面，我们在Student类中重写equals()方法。   </p>
<p>重写equals()方法后再次进行比较：<br> Student类：</p>
<pre><code>public class Student {  

String name;  

public Student(){  

}  

public Student(String name){  

    this.name=name;  

}  


public boolean equals(Object obj) {  
    if (this == obj)      //传入的对象就是它自己，如s.equals(s)；肯定是相等的；  
        return true;   
    if (obj == null)     //如果传入的对象是空，肯定不相等  
        return false;  
    if (getClass() != obj.getClass())  //如果不是同一个类型的，如Studnet类和Animal类，  
                                       //也不用比较了，肯定是不相等的  
        return false;  
    Student other = (Student) obj;       
    if (name == null) {  
        if (other.name != null)  
            return false;  
    } else if (!name.equals(other.name))   //如果name属性相等，则相等  
        return false;  
    return true;  
}  
</code></pre><p>}  </p>
<p>测试类Test：</p>
<pre><code>public class Test {  

public static void main(String[] args) {  

  Student s = new Student(&quot;BlueSky&quot;);  
  Student s1=new Student(&quot;BlueSky&quot;);  

  if(s.equals(s1)) System.out.println(&quot;s和是s1相等！&quot;);  
  else System.out.println(&quot;s和是s1不相等！&quot;);  
}  
</code></pre><p>}  </p>
<blockquote>
<p>运行结果：<br>“s和是s1相等！”</p>
</blockquote>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>1.当比较对象为基本数据类型的时候，”==“比较的是二者在栈内存中的值。</p>
<p>2.当比较对象为复杂数据类型的时候，当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，则比较结果为true。但string类有常量池的缘故较为特殊。</p>
<p>3.当比较对象为实体类的时候，不重写equals方法，比较的是二者在堆内存中的引用地址，无意义，一般在实体类中进行重写equals方法，自定义比较规则.</p>
<h2 id="附：Object的getClass方法与getName方法"><a href="#附：Object的getClass方法与getName方法" class="headerlink" title="附：Object的getClass方法与getName方法"></a>附：Object的getClass方法与getName方法</h2><h3 id="getClass方法："><a href="#getClass方法：" class="headerlink" title="getClass方法："></a>getClass方法：</h3><p>类型：public final Class&lt;? extends Object&gt; getClass()<br>功能：返回该对象的运行时类的Java.lang.Class对象（API上的解释）<br>有方法类型可以知道，该方法只能由类的实例变量调用<br>例子：</p>
<pre><code>[java] view plain copy
JButton b1 = new JButton(&quot;button1&quot;);  
System.out.println(b1.getClass());  
</code></pre><blockquote>
<p>输出：<br>    class javax.swing.JButton</p>
</blockquote>
<p>class属性<br>当你要获得一个类的Class对象时（作函数参数的时候），你不能调用getClass方法，那你只能用类名.class来达到效果<br>例子：</p>
<pre><code>[java] view plain copy
System.out.println(JButton.class);  
</code></pre><blockquote>
<p>输出：<br>class javax.swing.JButton</p>
</blockquote>
<h3 id="getName方法："><a href="#getName方法：" class="headerlink" title="getName方法："></a>getName方法：</h3><p>类型：public String getName()<br>功能：以String形式返回次Class对象所表示的实体名称<br>例子：</p>
<pre><code>[java] view plain copy
JButton b1 = new JButton(&quot;button1&quot;);  
System.out.println(b1.getName());  
</code></pre><blockquote>
<p>输出：<br>javax.swing.JButton</p>
</blockquote>
<p>可以发现用class属性和getClass返回的输出是一样的，用getName返回的比前面两种少了class和一个空格。</p>
</div><div class="tags"><a href="/tags/JDK探究/">JDK探究</a></div><div class="post-nav"><a class="pre" href="/2016/05/23/SpringBoot核心原理——自动配置/">Spring Boot核心原理－自动配置</a><a class="next" href="/2016/05/03/Rabbitmq基本原理/">Rabbitmq基本原理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JDK探究/">JDK探究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JDK探究/" style="font-size: 15px;">JDK探究</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/Spring探究/" style="font-size: 15px;">Spring探究</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/02/07/软负载中心与集中配置管理/">软负载中心与集中配置管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/25/消息中间件的设计与实践/">消息中间件的设计与实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/11/分布式系统幂等性解决方案/">分布式系统幂等性解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/19/读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地/">读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/18/读内藤树作品《青年们，读马克思吧》/">读内藤树作品《青年们，读马克思吧》</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/分布式事务通用解决方案/">分布式事务通用解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/线程安全与锁优化/">线程安全与锁优化——深入理解JVM阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/13/Java并发编程：volatile关键字解析/">Java并发编程：volatile关键字解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/事务的四大特性以及事务的四种隔离级别/">事务的四大特性以及事务的四种隔离级别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/悲观锁与乐观锁与事务/">悲观锁与乐观锁与事务</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">无题.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>