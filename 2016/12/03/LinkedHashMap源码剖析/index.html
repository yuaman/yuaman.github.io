
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="baidu-site-verification" content="LHYPl19xg9" />
<meta name="google-site-verification" content="s5HGo7JQp9QFcl2HIOHaNDUdwj3_kdgi5nPkB5bfMHs" />
  
  <title>LinkedHashmap源码剖析 | 无题</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="LinkedHashMap的源码理解起来也不难（当然，要建立在对HashMap源码有较好理解的基础上）。">
<meta name="keywords" content="Java容器相关">
<meta property="og:type" content="article">
<meta property="og:title" content="LinkedHashmap源码剖析">
<meta property="og:url" content="http://yoursite.com/2016/12/03/LinkedHashMap源码剖析/index.html">
<meta property="og:site_name" content="无题">
<meta property="og:description" content="LinkedHashMap的源码理解起来也不难（当然，要建立在对HashMap源码有较好理解的基础上）。">
<meta property="og:updated_time" content="2017-08-30T07:48:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LinkedHashmap源码剖析">
<meta name="twitter:description" content="LinkedHashMap的源码理解起来也不难（当然，要建立在对HashMap源码有较好理解的基础上）。">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">无题</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天南地北问乾坤</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-LinkedHashMap源码剖析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/03/LinkedHashMap源码剖析/" class="article-date">
  <time datetime="2016-12-03T09:37:31.000Z" itemprop="datePublished">2016-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LinkedHashmap源码剖析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LinkedHashMap的源码理解起来也不难（当然，要建立在对HashMap源码有较好理解的基础上）。<br><a id="more"></a><br>转载：<a href="http://blog.csdn.net/ns_code/article/details/37867985" target="_blank" rel="external">http://blog.csdn.net/ns_code/article/details/37867985</a></p>
<p>##LinkedHashMap简介</p>
<h4 id="LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同。"><a href="#LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同。" class="headerlink" title="LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同。"></a>LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同。</h4><p>LinkedHashMap可以用来实现LRU算法（这会在下面的源码中进行分析）。</p>
<p>LinkedHashMap同样是非线程安全的，只在单线程环境下使用。</p>
<p>##LinkedHashMap源码剖析</p>
<p>LinkedHashMap源码如下（加入了详细的注释）：</p>
<pre><code>[java] view plain copy 
1. package java.util;  
2. import java.io.*;  
3.   
4.   
5. public class LinkedHashMap&lt;K,V&gt;  
6.     extends HashMap&lt;K,V&gt;  
7.     implements Map&lt;K,V&gt;  
8. {  
9.   
10.     private static final long serialVersionUID = 3801124242820219131L;  
11.   
12.     //双向循环链表的头结点，整个LinkedHa只哟shMap中只有一个header，  
13.     //它将哈希表中所有的Entry贯穿起来，header中不保存key-value对，只保存前后节点的引用  
14.     private transient Entry&lt;K,V&gt; header;  
15.   
16.     //双向链表中元素排序规则的标志位。  
17.     //accessOrder为false，表示按插入顺序排序  
18.     //accessOrder为true，表示按访问顺序排序  
19.     private final boolean accessOrder;  
20.   
21.     //调用HashMap的构造方法来构造底层的数组  
22.     public LinkedHashMap(int initialCapacity, float loadFactor) {  
23.         super(initialCapacity, loadFactor);  
24.         accessOrder = false;    //链表中的元素默认按照插入顺序排序  
25.     }  
26.   
27.     //加载因子取默认的0.75f  
28.     public LinkedHashMap(int initialCapacity) {  
29.         super(initialCapacity);  
30.         accessOrder = false;  
31.     }  
32.   
33.     //加载因子取默认的0.75f，容量取默认的16  
34.     public LinkedHashMap() {  
35.         super();  
36.         accessOrder = false;  
37.     }  
38.   
39.     //含有子Map的构造方法，同样调用HashMap的对应的构造方法  
40.     public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) {  
41.         super(m);  
42.         accessOrder = false;  
43.     }  
44.   
45.     //该构造方法可以指定链表中的元素排序的规则  
46.     public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder) {  
47.         super(initialCapacity, loadFactor);  
48.         this.accessOrder = accessOrder;  
49.     }  
50.   
51.     //覆写父类的init()方法（HashMap中的init方法为空），  
52.     //该方法在父类的构造方法和Clone、readObject中在插入元素前被调用，  
53.     //初始化一个空的双向循环链表，头结点中不保存数据，头结点的下一个节点才开始保存数据。  
54.     void init() {  
55.         header = new Entry&lt;K,V&gt;(-1, null, null, null);  
56.         header.before = header.after = header;  
57.     }  
58.   
59.   
60.     //覆写HashMap中的transfer方法，它在父类的resize方法中被调用，  
61.     //扩容后，将key-value对重新映射到新的newTable中  
62.     //覆写该方法的目的是为了提高复制的效率，  
63.     //这里充分利用双向循环链表的特点进行迭代，不用对底层的数组进行for循环。  
64.     void transfer(HashMap.Entry[] newTable) {  
65.         int newCapacity = newTable.length;  
66.         for (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) {  
67.             int index = indexFor(e.hash, newCapacity);  
68.             e.next = newTable[index];  
69.             newTable[index] = e;  
70.         }  
71.     }  
72.   
73.   
74.     //覆写HashMap中的containsValue方法，  
75.     //覆写该方法的目的同样是为了提高查询的效率，  
76.     //利用双向循环链表的特点进行查询，少了对数组的外层for循环  
77.     public boolean containsValue(Object value) {  
78.         // Overridden to take advantage of faster iterator  
79.         if (value==null) {  
80.             for (Entry e = header.after; e != header; e = e.after)  
81.                 if (e.value==null)  
82.                     return true;  
83.         } else {  
84.             for (Entry e = header.after; e != header; e = e.after)  
85.                 if (value.equals(e.value))  
86.                     return true;  
87.         }  
88.         return false;  
89.     }  
90.   
91.   
92.     //覆写HashMap中的get方法，通过getEntry方法获取Entry对象。  
93.     //注意这里的recordAccess方法，  
94.     //如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做，  
95.     //如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处。  
96.     public V get(Object key) {  
97.         Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);  
98.         if (e == null)  
99.             return null;  
100.         e.recordAccess(this);  
101.         return e.value;  
102.     }  
103.   
104.     //清空HashMap，并将双向链表还原为只有头结点的空链表  
105.     public void clear() {  
106.         super.clear();  
107.         header.before = header.after = header;  
108.     }  
109.   
110.     //Enty的数据结构，多了两个指向前后节点的引用  
111.     private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; {  
112.         // These fields comprise the doubly linked list used for iteration.  
113.         Entry&lt;K,V&gt; before, after;  
114.   
115.         //调用父类的构造方法  
116.         Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) {  
117.             super(hash, key, value, next);  
118.         }  
119.   
120.         //双向循环链表中，删除当前的Entry  
121.         private void remove() {  
122.             before.after = after;  
123.             after.before = before;  
124.         }  
125.   
126.         //双向循环立链表中，将当前的Entry插入到existingEntry的前面  
127.         private void addBefore(Entry&lt;K,V&gt; existingEntry) {  
128.             after  = existingEntry;  
129.             before = existingEntry.before;  
130.             before.after = this;  
131.             after.before = this;  
132.         }  
133.   
134.   
135.         //覆写HashMap中的recordAccess方法（HashMap中该方法为空），  
136.         //当调用父类的put方法，在发现插入的key已经存在时，会调用该方法，  
137.         //调用LinkedHashmap覆写的get方法时，也会调用到该方法，  
138.         //该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部，  
139.         //accessOrder为true时，get方法会调用recordAccess方法  
140.         //put方法在覆盖key-value对时也会调用recordAccess方法  
141.         //它们导致Entry最近使用，因此将其移到双向链表的末尾  
142.         void recordAccess(HashMap&lt;K,V&gt; m) {  
143.             LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  
144.             //如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，  
145.             //如果是按照插入的先后顺序排序，则不做任何事情。  
146.             if (lm.accessOrder) {  
147.                 lm.modCount++;  
148.                 //移除当前访问的Entry  
149.                 remove();  
150.                 //将当前访问的Entry插入到链表的尾部  
151.                 addBefore(lm.header);  
152.             }  
153.         }  
154.   
155.         void recordRemoval(HashMap&lt;K,V&gt; m) {  
156.             remove();  
157.         }  
158.     }  
159.   
160.     //迭代器  
161.     private abstract class LinkedHashIterator&lt;T&gt; implements Iterator&lt;T&gt; {  
162.     Entry&lt;K,V&gt; nextEntry    = header.after;  
163.     Entry&lt;K,V&gt; lastReturned = null;  
164.   
165.     /** 
166.      * The modCount value that the iterator believes that the backing 
167.      * List should have.  If this expectation is violated, the iterator 
168.      * has detected concurrent modification. 
169.      */  
170.     int expectedModCount = modCount;  
171.   
172.     public boolean hasNext() {  
173.             return nextEntry != header;  
174.     }  
175.   
176.     public void remove() {  
177.         if (lastReturned == null)  
178.         throw new IllegalStateException();  
179.         if (modCount != expectedModCount)  
180.         throw new ConcurrentModificationException();  
181.   
182.             LinkedHashMap.this.remove(lastReturned.key);  
183.             lastReturned = null;  
184.             expectedModCount = modCount;  
185.     }  
186.   
187.     //从head的下一个节点开始迭代  
188.     Entry&lt;K,V&gt; nextEntry() {  
189.         if (modCount != expectedModCount)  
190.         throw new ConcurrentModificationException();  
191.             if (nextEntry == header)  
192.                 throw new NoSuchElementException();  
193.   
194.             Entry&lt;K,V&gt; e = lastReturned = nextEntry;  
195.             nextEntry = e.after;  
196.             return e;  
197.     }  
198.     }  
199.   
200.     //key迭代器  
201.     private class KeyIterator extends LinkedHashIterator&lt;K&gt; {  
202.     public K next() { return nextEntry().getKey(); }  
203.     }  
204.   
205.     //value迭代器  
206.     private class ValueIterator extends LinkedHashIterator&lt;V&gt; {  
207.     public V next() { return nextEntry().value; }  
208.     }  
209.   
210.     //Entry迭代器  
211.     private class EntryIterator extends LinkedHashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {  
212.     public Map.Entry&lt;K,V&gt; next() { return nextEntry(); }  
213.     }  
214.   
215.     // These Overrides alter the behavior of superclass view iterator() methods  
216.     Iterator&lt;K&gt; newKeyIterator()   { return new KeyIterator();   }  
217.     Iterator&lt;V&gt; newValueIterator() { return new ValueIterator(); }  
218.     Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() { return new EntryIterator(); }  
219.   
220.   
221.     //覆写HashMap中的addEntry方法，LinkedHashmap并没有覆写HashMap中的put方法，  
222.     //而是覆写了put方法所调用的addEntry方法和recordAccess方法，  
223.     //put方法在插入的key已存在的情况下，会调用recordAccess方法，  
224.     //在插入的key不存在的情况下，要调用addEntry插入新的Entry  
225.     void addEntry(int hash, K key, V value, int bucketIndex) {  
226.         //创建新的Entry，并插入到LinkedHashMap中  
227.         createEntry(hash, key, value, bucketIndex);  
228.   
229.         //双向链表的第一个有效节点（header后的那个节点）为近期最少使用的节点  
230.         Entry&lt;K,V&gt; eldest = header.after;  
231.         //如果有必要，则删除掉该近期最少使用的节点，  
232.         //这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  
233.         if (removeEldestEntry(eldest)) {  
234.             removeEntryForKey(eldest.key);  
235.         } else {  
236.             //扩容到原来的2倍  
237.             if (size &gt;= threshold)  
238.                 resize(2 * table.length);  
239.         }  
240.     }  
241.   
242.     void createEntry(int hash, K key, V value, int bucketIndex) {  
243.         //创建新的Entry，并将其插入到数组对应槽的单链表的头结点处，这点与HashMap中相同  
244.         HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  
245.         Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old);  
246.         table[bucketIndex] = e;  
247.         //每次插入Entry时，都将其移到双向链表的尾部，  
248.         //这便会按照Entry插入LinkedHashMap的先后顺序来迭代元素，  
249.         //同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，符合LRU算法的实现  
250.         e.addBefore(header);  
251.         size++;  
252.     }  
253.   
254.     //该方法是用来被覆写的，一般如果用LinkedHashmap实现LRU算法，就要覆写该方法，  
255.     //比如可以将该方法覆写为如果设定的内存已满，则返回true，这样当再次向LinkedHashMap中put  
256.     //Entry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。  
257.     protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {  
258.         return false;  
259.     }  
260. }  
</code></pre><p>##几点总结</p>
<p>关于LinkedHashMap的源码，给出以下几点比较重要的总结：</p>
<h4 id="1、从源码中可以看出，LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序依次加入到以head为头结点的双向循环链表的尾部。"><a href="#1、从源码中可以看出，LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序依次加入到以head为头结点的双向循环链表的尾部。" class="headerlink" title="1、从源码中可以看出，LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序依次加入到以head为头结点的双向循环链表的尾部。"></a>1、从源码中可以看出，LinkedHashMap中加入了一个head头结点，将所有插入到该LinkedHashMap中的Entry按照插入的先后顺序依次加入到以head为头结点的双向循环链表的尾部。</h4><h4 id="实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如第一个图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。"><a href="#实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如第一个图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。" class="headerlink" title="实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如第一个图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。"></a>实际上就是HashMap和LinkedList两个集合类的存储结构的结合。在LinkedHashMapMap中，所有put进来的Entry都保存在如第一个图所示的哈希表中，但它又额外定义了一个以head为头结点的空的双向循环链表，每次put进来Entry，除了将其保存到对哈希表中对应的位置上外，还要将其插入到双向循环链表的尾部。</h4><h4 id="2、LinkedHashMap由于继承自HashMap，因此它具有HashMap的所有特性，同样允许key和value为null。"><a href="#2、LinkedHashMap由于继承自HashMap，因此它具有HashMap的所有特性，同样允许key和value为null。" class="headerlink" title="2、LinkedHashMap由于继承自HashMap，因此它具有HashMap的所有特性，同样允许key和value为null。"></a>2、LinkedHashMap由于继承自HashMap，因此它具有HashMap的所有特性，同样允许key和value为null。</h4><h4 id="3、注意源码中的accessOrder标志位，当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；当它为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。"><a href="#3、注意源码中的accessOrder标志位，当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；当它为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。" class="headerlink" title="3、注意源码中的accessOrder标志位，当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；当它为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。"></a>3、注意源码中的accessOrder标志位，当它false时，表示双向链表中的元素按照Entry插入LinkedHashMap到中的先后顺序排序，即每次put到LinkedHashMap中的Entry都放在双向链表的尾部，这样遍历双向链表时，Entry的输出顺序便和插入的顺序一致，这也是默认的双向链表的存储顺序；当它为true时，表示双向链表中的元素按照访问的先后顺序排列，可以看到，虽然Entry插入链表的顺序依然是按照其put到LinkedHashMap中的顺序，但put和get方法均有调用recordAccess方法（put方法在key相同，覆盖原有的Entry的情况下调用recordAccess方法），该方法判断accessOrder是否为true，如果是，则将当前访问的Entry（put进来的Entry或get出来的Entry）移到双向链表的尾部（key不相同时，put新Entry时，会调用addEntry，它会调用creatEntry，该方法同样将新插入的元素放入到双向链表的尾部，既符合插入的先后顺序，又符合访问的先后顺序，因为这时该Entry也被访问了），否则，什么也不做。</h4><h4 id="4、注意构造方法，前四个构造方法都将accessOrder设为false，说明默认是按照插入顺序排序的，而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则，一般要用LinkedHashMap实现LRU算法，就要用该构造方法，将accessOrder置为true。"><a href="#4、注意构造方法，前四个构造方法都将accessOrder设为false，说明默认是按照插入顺序排序的，而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则，一般要用LinkedHashMap实现LRU算法，就要用该构造方法，将accessOrder置为true。" class="headerlink" title="4、注意构造方法，前四个构造方法都将accessOrder设为false，说明默认是按照插入顺序排序的，而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则，一般要用LinkedHashMap实现LRU算法，就要用该构造方法，将accessOrder置为true。"></a>4、注意构造方法，前四个构造方法都将accessOrder设为false，说明默认是按照插入顺序排序的，而第五个构造方法可以自定义传入的accessOrder的值，因此可以指定双向循环链表中元素的排序规则，一般要用LinkedHashMap实现LRU算法，就要用该构造方法，将accessOrder置为true。</h4><h4 id="5、LinkedHashMap并没有覆写HashMap中的put方法，而是覆写了put方法中调用的addEntry方法和recordAccess方法，我们回过头来再看下HashMap的put方法："><a href="#5、LinkedHashMap并没有覆写HashMap中的put方法，而是覆写了put方法中调用的addEntry方法和recordAccess方法，我们回过头来再看下HashMap的put方法：" class="headerlink" title="5、LinkedHashMap并没有覆写HashMap中的put方法，而是覆写了put方法中调用的addEntry方法和recordAccess方法，我们回过头来再看下HashMap的put方法："></a>5、LinkedHashMap并没有覆写HashMap中的put方法，而是覆写了put方法中调用的addEntry方法和recordAccess方法，我们回过头来再看下HashMap的put方法：</h4><pre><code>[java] view plain copy 
1. // 将“key-value”添加到HashMap中      
2. public V put(K key, V value) {      
3.     // 若“key为null”，则将该键值对添加到table[0]中。      
4.     if (key == null)      
5.         return putForNullKey(value);      
6.     // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。      
7.     int hash = hash(key.hashCode());      
8.     int i = indexFor(hash, table.length);      
9.     for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {      
10.         Object k;      
11.         // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！      
12.         if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {      
13.             V oldValue = e.value;      
14.             e.value = value;      
15.             e.recordAccess(this);      
16.             return oldValue;      
17.         }      
18.     }      
19.   
20.     // 若“该key”对应的键值对不存在，则将“key-value”添加到table中      
21.     modCount++;    
22.     //将key-value添加到table[i]处    
23.     addEntry(hash, key, value, i);      
24.     return null;      
25. }      
</code></pre><p>当要put进来的Entry的key在哈希表中已经在存在时，会调用recordAccess方法，当该key不存在时，则会调用addEntry方法将新的Entry插入到对应槽的单链表的头部。<br>    我们先来看recordAccess方法：</p>
<pre><code>[java] view plain copy 
1. //覆写HashMap中的recordAccess方法（HashMap中该方法为空），  
2. //当调用父类的put方法，在发现插入的key已经存在时，会调用该方法，  
3. //调用LinkedHashmap覆写的get方法时，也会调用到该方法，  
4. //该方法提供了LRU算法的实现，它将最近使用的Entry放到双向循环链表的尾部，  
5. //accessOrder为true时，get方法会调用recordAccess方法  
6. //put方法在覆盖key-value对时也会调用recordAccess方法  
7. //它们导致Entry最近使用，因此将其移到双向链表的末尾  
8.       void recordAccess(HashMap&lt;K,V&gt; m) {  
9.           LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  
10.     //如果链表中元素按照访问顺序排序，则将当前访问的Entry移到双向循环链表的尾部，  
11.     //如果是按照插入的先后顺序排序，则不做任何事情。  
12.           if (lm.accessOrder) {  
13.               lm.modCount++;  
14.         //移除当前访问的Entry  
15.               remove();  
16.         //将当前访问的Entry插入到链表的尾部  
17.               addBefore(lm.header);  
18.           }  
19.       }  
</code></pre><p>该方法会判断accessOrder是否为true，如果为true，它会将当前访问的Entry（在这里指put进来的Entry）移动到双向循环链表的尾部，从而实现双向链表中的元素按照访问顺序来排序（最近访问的Entry放到链表的最后，这样多次下来，前面就是最近没有被访问的元素，在实现、LRU算法时，当双向链表中的节点数达到最大值时，将前面的元素删去即可，因为前面的元素是最近最少使用的），否则什么也不做。</p>
<p>再来看addEntry方法：</p>
<pre><code>[java] view plain copy 
1. //覆写HashMap中的addEntry方法，LinkedHashmap并没有覆写HashMap中的put方法，  
2. //而是覆写了put方法所调用的addEntry方法和recordAccess方法，  
3. //put方法在插入的key已存在的情况下，会调用recordAccess方法，  
4. //在插入的key不存在的情况下，要调用addEntry插入新的Entry  
5.    void addEntry(int hash, K key, V value, int bucketIndex) {  
6.     //创建新的Entry，并插入到LinkedHashMap中  
7.        createEntry(hash, key, value, bucketIndex);  
8.   
9.        //双向链表的第一个有效节点（header后的那个节点）为近期最少使用的节点  
10.        Entry&lt;K,V&gt; eldest = header.after;  
11.     //如果有必要，则删除掉该近期最少使用的节点，  
12.     //这要看对removeEldestEntry的覆写,由于默认为false，因此默认是不做任何处理的。  
13.        if (removeEldestEntry(eldest)) {  
14.            removeEntryForKey(eldest.key);  
15.        } else {  
16.         //扩容到原来的2倍  
17.            if (size &gt;= threshold)  
18.                resize(2 * table.length);  
19.        }  
20.    }  
21.   
22.    void createEntry(int hash, K key, V value, int bucketIndex) {  
23.     //创建新的Entry，并将其插入到数组对应槽的单链表的头结点处，这点与HashMap中相同  
24.        HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  
25.     Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old);  
26.        table[bucketIndex] = e;  
27.     //每次插入Entry时，都将其移到双向链表的尾部，  
28.     //这便会按照Entry插入LinkedHashMap的先后顺序来迭代元素，  
29.     //同时，新put进来的Entry是最近访问的Entry，把其放在链表末尾 ，符合LRU算法的实现  
30.        e.addBefore(header);  
31.        size++;  
32.    }  
</code></pre><p>同样是将新的Entry插入到table中对应槽所对应单链表的头结点中，但可以看出，在createEntry中，同样把新put进来的Entry插入到了双向链表的尾部，从插入顺序的层面来说，新的Entry插入到双向链表的尾部，可以实现按照插入的先后顺序来迭代Entry，而从访问顺序的层面来说，新put进来的Entry又是最近访问的Entry，也应该将其放在双向链表的尾部。<br>    上面还有个removeEldestEntry方法，该方法如下：</p>
<pre><code>[java] view plain copy 
1.     //该方法是用来被覆写的，一般如果用LinkedHashmap实现LRU算法，就要覆写该方法，  
2.     //比如可以将该方法覆写为如果设定的内存已满，则返回true，这样当再次向LinkedHashMap中put  
3.     //Entry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）。  
4.     protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {  
5.         return false;  
6.     }  
7. }  
    该方法默认返回false，我们一般在用LinkedHashMap实现LRU算法时，要覆写该方法，一般的实现是，当设定的内存（这里指节点个数）达到最大值时，返回true，这样put新的Entry（该Entry的key在哈希表中没有已经存在）时，就会调用removeEntryForKey方法，将最近最少使用的节点删除（head后面的那个节点，实际上是最近没有使用）。
    6、LinkedHashMap覆写了HashMap的get方法：
[java] view plain copy 
1. //覆写HashMap中的get方法，通过getEntry方法获取Entry对象。  
2. //注意这里的recordAccess方法，  
3. //如果链表中元素的排序规则是按照插入的先后顺序排序的话，该方法什么也不做，  
4. //如果链表中元素的排序规则是按照访问的先后顺序排序的话，则将e移到链表的末尾处。  
5.    public V get(Object key) {  
6.        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);  
7.        if (e == null)  
8.            return null;  
9.        e.recordAccess(this);  
10.        return e.value;  
11.    }  
</code></pre><p>先取得Entry，如果不为null，一样调用recordAccess方法，上面已经说得很清楚，这里不在多解释了。</p>
<p>7、最后说说LinkedHashMap是如何实现LRU的。首先，当accessOrder为true时，才会开启按访问顺序排序的模式，才能用来实现LRU算法。我们可以看到，无论是put方法还是get方法，都会导致目标Entry成为最近访问的Entry，因此便把该Entry加入到了双向链表的末尾（get方法通过调用recordAccess方法来实现，put方法在覆盖已有key的情况下，也是通过调用recordAccess方法来实现，在插入新的Entry时，则是通过createEntry中的addBefore方法来实现），这样便把最近使用了的Entry放入到了双向链表的后面，多次操作后，双向链表前面的Entry便是最近没有使用的，这样当节点个数满的时候，删除的最前面的Entry(head后面的那个Entry)便是最近最少使用的Entry。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/12/03/LinkedHashMap源码剖析/" data-id="cjcw1cq1a000lg5739upvli2x" class="article-share-link" data-share="baidu" data-title="LinkedHashmap源码剖析">分享到</a>
      



      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java容器相关/">Java容器相关</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/03/Redis常见问题整理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          Redis常见问题整理
        
      </div>
    </a>
  
  
    <a href="/2016/12/03/synchronized关键字、ReentrantLock与原子类比较/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">synchronized、ReentrantLock与原子类</div>
    </a>
  
</nav>

  



</article>



</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM相关/">JVM相关</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java容器相关/">Java容器相关</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/个人开源项目/">个人开源项目</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式消息/">分布式消息</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式缓存/">分布式缓存</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发相关/">并发相关</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/感悟/">感悟</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作记录/">操作记录</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架相关/">框架相关</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高并发方案/">高并发方案</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JVM相关/" style="font-size: 18.33px;">JVM相关</a> <a href="/tags/Java基础/" style="font-size: 13.33px;">Java基础</a> <a href="/tags/Java容器相关/" style="font-size: 16.67px;">Java容器相关</a> <a href="/tags/个人开源项目/" style="font-size: 11.67px;">个人开源项目</a> <a href="/tags/分布式消息/" style="font-size: 11.67px;">分布式消息</a> <a href="/tags/分布式缓存/" style="font-size: 20px;">分布式缓存</a> <a href="/tags/并发相关/" style="font-size: 15px;">并发相关</a> <a href="/tags/感悟/" style="font-size: 10px;">感悟</a> <a href="/tags/操作记录/" style="font-size: 13.33px;">操作记录</a> <a href="/tags/框架相关/" style="font-size: 13.33px;">框架相关</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a> <a href="/tags/高并发方案/" style="font-size: 15px;">高并发方案</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/19/读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地/">读《毛选》第二卷《苏联利益与人类利益相一致》，看毛泽东如何给斯大林强势洗地</a>
          </li>
        
          <li>
            <a href="/2017/09/18/读内藤树作品《青年们，读马克思吧》/">读内藤树作品《青年们，读马克思吧》</a>
          </li>
        
          <li>
            <a href="/2017/09/18/一个97年的IT人创业历程中的总结和感悟/">一个97年的IT人创业历程中的总结和感悟</a>
          </li>
        
          <li>
            <a href="/2017/08/18/分布式事务通用解决方案/">分布式事务通用解决方案</a>
          </li>
        
          <li>
            <a href="/2017/08/17/创业一段时间的总结和感悟/">创业感悟</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/yuaman" target="_blank">我的git同性交友主页</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  



  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 yutinglin<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>



</footer>


  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->









</div>
</body>
</html>
