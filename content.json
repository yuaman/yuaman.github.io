{"meta":{"title":"无题","subtitle":"天南地北问乾坤","description":null,"author":"yutinglin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"JVM GC要点整理与总结（转载）","slug":"JVM GC要点整理与总结（转载）","date":"2017-08-15T06:41:09.000Z","updated":"2017-08-14T06:42:11.000Z","comments":true,"path":"2017/08/15/JVM GC要点整理与总结（转载）/","link":"","permalink":"http://yoursite.com/2017/08/15/JVM GC要点整理与总结（转载）/","excerpt":"这边文章是我偶然看到的一篇对JVM GC部分的要点整理的比较全面比较详细的一篇文章，所以大胆转载了过来，也是给我个人做一个备忘和参考，或许以后也会在这个基础之上进行补充。这是原文的地址：http://blog.leanote.com/post/shiwei/Java-GC?spm=5176.100239.blogcont91017.9.3Qo1pk请大家支持原作者，感谢原作者的认真和辛勤整理。","text":"这边文章是我偶然看到的一篇对JVM GC部分的要点整理的比较全面比较详细的一篇文章，所以大胆转载了过来，也是给我个人做一个备忘和参考，或许以后也会在这个基础之上进行补充。这是原文的地址：http://blog.leanote.com/post/shiwei/Java-GC?spm=5176.100239.blogcont91017.9.3Qo1pk请大家支持原作者，感谢原作者的认真和辛勤整理。 范围：要回收哪些区域在JVM五种内存模型中，有三个是不需要进行垃圾回收的：程序计数器、JVM栈、本地方法栈。因为它们的生命周期是和线程同步的，随着线程的销毁，它们占用的内存会自动释放，所以只有方法区和堆需要进行GC。 前提：如何判断对象已死所有的垃圾收集算法都面临同一个问题，那就是找出应用程序不可到达的内存块，将其释放，这里面讲的不可达主要是指应用程序已经没有内存块的引用了， 在Java中，某个对象对应用程序是可到达的是指：这个对象被根（根主要是指类的静态变量，或者活跃在所有线程栈的对象的引用）引用或者对象被另一个可到达的对象引用。 引用计数算法引用计数是最简单直接的一种方式，这种方式在每一个对象中增加一个引用的计数，这个计数代表当前程序有多少个引用引用了此对象，如果此对象的引用计数变为0，那么此对象就可以作为垃圾收集器的目标对象来收集。优点：简单，直接，不需要暂停整个应用缺点：1.需要编译器的配合，编译器要生成特殊的指令来进行引用计数的操作；2.不能处理循环引用的问题因此这种方法是垃圾收集的早期策略，现在很少使用。Sun的JVM并没有采用引用计数算法来进行垃圾回收，而是基于根搜索算法的。 可达性分析算法（根搜索算法）通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。 在java语言中，可作为GCRoot的对象包括以下几种：a. java虚拟机栈(栈帧中的本地变量表)中的引用的对象。b.方法区中的类静态属性引用的对象。c.方法区中的常量引用的对象。d.本地方法栈中JNI本地方法的引用对象。 ###四种引用GC在收集一个对象的时候会判断是否有引用指向对象，在JAVA中的引用主要有四种： 强引用（Strong Reference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 软引用（Soft Reference）如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了内存溢出的问题。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 弱引用（Weak Reference）弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 虚引用（Phantom Reference）“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用于检测对象是否已经从内存中删除，跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。虚引用的唯一目的是当对象被回收时收到一个系统通知。 finalize() 方法通过可达性分析，那些不可达的对象并不是立即被销毁，他们还有被拯救的机会。如果要回收一个不可达的对象，要经历两次标记过程。首先是第一次标记，并判断对象是否覆写了 finalize 方法，如果没有覆写，则直接进行第二次标记并被回收。如果对象有覆写finalize 方法，则会将改对象加入一个叫“F-Queue”的队列中，虚拟机会建立一个低优先级的 Finalizer 线程去执行它，这里说的“执行”是指该线程会去触发 finalize 方法，但是并不会等待 finalize 方法执行完成。主要是因为 finalize 方法的不确定性，它可能要花很长时间才能执行完成，甚至死循环，永远不结束，这将导致整个 GC 工作的异常，甚至崩溃。关于拯救，可以在 finalize 方法中将自己（this关键字）赋值给类变量或其他对象的成员变量，则第二次标记时它将被移出回收的集合，如果对象并未被拯救，则最终被回收。finalize 方法只会被调用一次，如果一个在 finalize 被拯救的对象再次需要回收，则它的 finalize 将不会再被触发了。不建议使用finalize 方法，它的运行代价高，不确定性大，GC 也不会等待它执行完成，它的功能完全可以被 try-finally 代替。 方法区的回收方法区也会被回收，其被回收的内存有：废弃常量、无用的类。在 HotSpot 虚拟机规范里，将永久带作为方法区的实现。废弃常量：没有被引用的常量，如 String。判断无用的类：(1).该类的所有实例都已经被回收，即java堆中不存在该类的实例对象。(2).加载该类的类加载器已经被回收。(3).该类所对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射机制访问该类的方法。 各种垃圾收集算法标记-清除算法步骤：1、标记：从根集合开始扫描，标记存活对象；2、清除：再次扫描真个内存空间，回收未被标记的对象。此算法一般没有虚拟机采用优点1：解决了循环引用的问题优点2：与复制算法相比，不需要对象移动，效率较高，而且还不需要额外的空间不足1：每个活跃的对象都要进行扫描，而且要扫描两次，效率较低，收集暂停的时间比较长。不足2：产生不连续的内存碎片 标记-整理（压缩）算法对标记-清除算法的改进标记过程与标记-清除算法一样，但是标记完成后，存活对象向一端移动，然后清理边界的内存步骤：1、标记：从根集合开始扫描，标记存活对象；2、整理：再次扫描真个内存空间，并往内存一段移动存活对象，再清理掉边界的对象。不会产生内存碎片，但是依旧移动对象的成本。适合老年代还有一种算法是标记-清除-整理（压缩），是在多次标记清除后，再进行一次整理，这样就减少了移动对象的成本。 复制算法将内存分成两块容量大小相等的区域，每次只使用其中一块，当这一块内存用完了，就将所有存活对象复制到另一块内存空间，然后清除前一块内存空间。此种方法实现简单、效率较高，优点：1、不会产生内存碎；2、没有了先标记再删除的步骤，而是通过Tracing从 From内存中找到存活对象，复制到另一块To内存区域，From只要移动堆顶指针便可再次使用。缺点：1、复制的代价较高，所有适合新生代，因为新生代的对象存活率较低，需要复制的对象较少；2、需要双倍的内存空间，而且总是有一块内存空闲，浪费空间。 分代收集算法所有商业虚拟机都采用这种方式，将堆分成新生代和老年代，新生代使用复制算法，老年代使用标记-整理算法 GC 类型1.Minor GC 针对新生代的 GC2.Major GC 针对老年代的 GC3.Full GC 针对新生代、老年代、永久带的 GC 为什么要分不同的 GC 类型，主要是1、对象有不同的生命周期，经研究，98%的对象都是临时对象；2、根据各代的特点应用不同的 GC 算法，提高 GC 效率。 各种垃圾收集器###串行收集器（Serial Collector）单线程，会发生停顿适用场景：1.单 CPU、新生代小、对停顿时间要求不高的应用2.client 模式下或32位 Windows 上的默认收集器新生代均采用复制算法，老年代用标记-整理算法（Serial Old Collector）在单核 CPU 上面的运行效果较好，甚至可能超过并行垃圾收集器，因为并行垃圾收集器有线程的切换消耗。当 Eden 空间分配不足时触发原理：1.拷贝 Eden 和 From 空间的存活对象到 To 空间2.部分对象可能晋升到老年代（大对象、达到年龄的对象、To 空间不足时）3.清空 Eden、From 空间，From 与 To 空间交换角色 ParNew（Serial 收集器的多线程版本）新生代收集器，是 Serial 的多线程版，是 Server 模式下的虚拟机中首选的新生代收集器，不是默认收集器。除了 Serial 外，是唯一能与 CMS 收集器配合工作的收集器。多线程下，性能较好，单线程下，并不会比 Serial 好。 并行收集器（Parallel Scavenge）特性：1.并行、停顿2.并行线程数：CPU &lt;= 8 := 8,CPU &gt; 8 := (3+ cpu * 5) / 8,也可强制指定 GC 线程数3.自适应调节策略，如果把该策略打开，则虚拟机会自动调整新生代的大小比例和晋升老年代的对象大小、年龄等细节参数4.吞吐量优先收集器，即可用设置一个 GC 时间，收集器将尽可能的在该时间内完成 GC 吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间），即吞吐量越高，则垃圾收集时间就要求越短用户可以设置最大垃圾收集停顿时间或者吞吐量但并不是把最大垃圾收集停顿时间设置得越短越好，因为它是以牺牲吞吐量和新生代空间的代价来换取的，比如收集300M 空间总会比收集500M 空间更快，再如收集频率加高，本来10秒收集一次，每次停顿100毫秒，但是现在改成了5秒收集一次，每次停顿70毫秒，停顿时间是小了，但是吞吐量确也降下来了。 适用场景：1.多 CPU、对停顿时间要求高的应用2.是 Server 端的默认新生代收集器 Serial Old是 Serial 收集器的老年代版本，依旧是单线程收集器，采用标记-整理算法， Parallel Old略 CMS（并发-标记-清除）CMS 是一种以获取最短回收停顿时间为目标的收集器。步骤：1.初始标记此阶段仅仅是标记一下 GC Roots 能直接关联到的对象，速度很快，但是会停顿 注意：这里不是 GC Roots Tracing 的过程2.并发标记GC Roots Tracing 的过程，这个阶段可以与用户线程一起工作，不会造成停顿,从而导致整个停顿时间大大降低3.重新标记是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录4.并发清除优点：停顿时间短，但是总的 GC 时间长缺点：1.并发程序都是 CPU 敏感的，并发标记和并发清除可能会抢占应用 CPU2.总的 GC 时间长3.无法处理浮动垃圾 浮动垃圾：在并发清除过程中，程序还在运行，可能产生新的垃圾，但是本次 GC 确不可能清除掉这些新产生的垃圾了，所以这些新产生垃圾就叫浮动垃圾，也就是说在一次 CMS 的 GC 后，用户获取不到一个完全干净的内存空间，还是或多或少存在浮动垃圾的。4.由于在并发标记和并发清除阶段，用户程序依旧在运行，所以也就需要为用户程序的运行预留一定空间，而不能想其他收集器一样会暂停用户程序的运行。在此期间，就可能发生预留空间不足，导致程序异常的情况。5.是基于标记-清除的收集器，所以会产生内存碎片 G1这款开发了10多年的收集器还比较年轻，目前还很少听说有人在生产环境使用。此款收集器可以独立管理整个 java heap 空间，而不需要其他收集器的配合。步骤： 初始标记与CMS 一样，只是标记一下 GC Roots 能直接关联到的对象，速度很快，但是需要停顿 并发标记GC Roots Tracing 过程，并发执行 最终标记并行执行，需要停顿 筛选回收并行执行，需要停顿 G1收集器把 Heap 分为多个大小相等的 Region，G1可以有计划的避免进行全区域的垃圾收集。G1跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值大的 Regin，保证 G1收集器在有限时间内获取最大的收集效率。 优点： 存在并发与并行操作，最大化利用硬件资源，提升收集效率 分代收集，虽然 G1可以独立管理整个 Heap，但是它还是保留了分代的概念，实际上,在分区时，这些区域(regions)被映射为逻辑上的 Eden, Survivor, 和 old generation(老年代)空间，使其有目的的收集特定区域的内存。titlehttp://og287lnu0.bkt.clouddn.com/591d52e2ab64412be90016a5 空间整合，G1回收内存时，是将某个或多个区域的存活对象拷贝至其他空区域，同时释放被拷贝的内存区域，这种方式在整体上看是标记-整理，在局部看（两个 Region 之间）是复制算法，所以不会产生内存碎片 可预测的停顿时间 内存分配策略对象优先在 Eden 区分配大对象直接进入老年代长期存活的对象将进入老年代动态对象年龄判断。并不是新生代对象的年龄一定要达到某个值，才会进入老年代。Survivor空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，那么年龄等于或大于该年龄的对象就直接进入老年代，无须等待设置的年龄空间分配担保","categories":[],"tags":[{"name":"JVM相关","slug":"JVM相关","permalink":"http://yoursite.com/tags/JVM相关/"}]},{"title":"谈谈Java中equals和==的区别和使用场景","slug":"Java中equals与==的区别与使用场景分析","date":"2017-08-14T04:44:54.000Z","updated":"2017-08-14T04:50:07.000Z","comments":true,"path":"2017/08/14/Java中equals与==的区别与使用场景分析/","link":"","permalink":"http://yoursite.com/2017/08/14/Java中equals与==的区别与使用场景分析/","excerpt":"讨论一下Java中equals和==的区别，这个问题看似浅显，还是有不少情况需要注意。阅览了网上一些文章，都比较片面。在此做一下详细的整理。","text":"讨论一下Java中equals和==的区别，这个问题看似浅显，还是有不少情况需要注意。阅览了网上一些文章，都比较片面。在此做一下详细的整理。 先直接上结论：：1.当比较对象为基本数据类型的时候，”==“比较的是二者在栈内存中的值。 2.当比较对象为复杂数据类型的时候，当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，比较结果为true。但string类有常量池的缘故较为特殊。 3.当比较对象为实体类的时候，不重写equals方法，比较的是二者在堆内存中的引用地址，无意义，一般在实体类中进行重写equals方法，自定义比较规则。 java中的数据类型，可分为两类：1.基本数据类型，也称原始数据类型的比较。byte,short,char,int,long,float,double,boolean 他们之间的比较，应用双等号（==）,比较的是他们的值。 示例： public class Test { public static void main(String[] args) { int i=5; int j=5; if(i==j) System.out.println(&quot;i和j相等！&quot;); else System.out.println(&quot;不相等！&quot;); } 运行结果： “i和j相等！” 因为此时比较对象为基本数据类型，所以“==”比较的是它们存放于虚拟机栈内存中的值。 2.复杂数据类型的比较在Java API中，有些类重写了equals()方法，它们的比较规则是：当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，则比较结果为true。这些类包括：String、Double、Float、Long、Integer、Short、Byte、、Boolean、BigDecimal、BigInteger等等，太多太多了，但是常见的就这些了，具体可以查看API中类的equals()方法，就知道了。 深入到内存中。==就是比较堆内存的值是否相等（对象地址存放在堆内存），equals（）就是比较栈内存的值（对象的值存在于栈内存）。String有个常量池。String a=”abc”;String b=”abc”;a==b是返回true的，就是因为常量池的原因，实际上a和b是同一个对象。但是String a=”abc”;String a=new String(“abc”);这样a==b就是返回flase了，a和b就不是同一个对象（他们的地址不等。） 原来，程序在运行的时候会创建一个字符串缓冲池当使用 s2 = “Monday” 这样的表达是创建字符串的时候，程序首先会在这个String缓冲池中寻找相同值的对象，在第一个程序中，s1先被放到了池中，所以在s2被创建的时候，程序找到了具有相同值的 s1将s2引用s1所引用的对象”Monday”第二段程序中，使用了 new 操作符，他明白的告诉程序：”我要一个新的！不要旧的！”于是一个新的”Monday”Sting对象被创建在内存中。他们的值相同，但是位置不同，一个在池中游泳一个在岸边休息。哎呀，真是资源浪费，明明是一样的非要分开做什么呢？ 3.实体类的比较 当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址。 对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 示例： public class Student { String name; public Student(){ } public Student(String name){ this.name=name; } public class Test { public static void main(String[] args) { Student s = new Student(&quot;BlueSky&quot;); Student s1=new Student(&quot;BlueSky&quot;); if(s==s1) System.out.println(&quot;s和是s1相等！&quot;); else System.out.println(&quot;s和是s1不相等！&quot;); if(s.equals(s1)) System.out.println(&quot;s和是s1相等！&quot;); else System.out.println(&quot;s和是s1不相等！&quot;); } } 运行结果：s和是s1不相等！s和是s1不相等！ 结果验证了Object类的equals()方法用来比较是否一个对象是利用内存地址比较，所以在定义一个类的时候，如果涉及到对象的比较（通过我们要比较内容），应该重写equals()方法。重写的一般规则是： 1、先用“==”判断是否相等。 2、判断equals()方法的参数是否为null，如果为null，则返回false；因为当前对象不可能为null，如果为null，则不能调用其equals()方法，否则抛java.lang.NullPointerException异常。 3、当参数不为null，则如果两个对象的运行时类（通过getClass()获取）不相等，返回false，否则继续判断。 4、判断类的成员是否对应相等。往下就随意发挥了。呵呵！ 我们对实体进行比较的时候往往要比较的是里面的值，所以我们为了达到这个目的，要在实体类里面重写equals()方法，进行对象里面的内容比较。如上面，我们在Student类中重写equals()方法。 重写equals()方法后再次进行比较： Student类： public class Student { String name; public Student(){ } public Student(String name){ this.name=name; } public boolean equals(Object obj) { if (this == obj) //传入的对象就是它自己，如s.equals(s)；肯定是相等的； return true; if (obj == null) //如果传入的对象是空，肯定不相等 return false; if (getClass() != obj.getClass()) //如果不是同一个类型的，如Studnet类和Animal类， //也不用比较了，肯定是不相等的 return false; Student other = (Student) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) //如果name属性相等，则相等 return false; return true; } } 测试类Test： public class Test { public static void main(String[] args) { Student s = new Student(&quot;BlueSky&quot;); Student s1=new Student(&quot;BlueSky&quot;); if(s.equals(s1)) System.out.println(&quot;s和是s1相等！&quot;); else System.out.println(&quot;s和是s1不相等！&quot;); } } 运行结果：“s和是s1相等！” 结论：1.当比较对象为基本数据类型的时候，”==“比较的是二者在栈内存中的值。 2.当比较对象为复杂数据类型的时候，当且仅当该equals方法参数不是 null，两个变量的类型、内容都相同，则比较结果为true。但string类有常量池的缘故较为特殊。 3.当比较对象为实体类的时候，不重写equals方法，比较的是二者在堆内存中的引用地址，无意义，一般在实体类中进行重写equals方法，自定义比较规则. 附：Object的getClass方法与getName方法getClass方法：类型：public final Class&lt;? extends Object&gt; getClass()功能：返回该对象的运行时类的Java.lang.Class对象（API上的解释）有方法类型可以知道，该方法只能由类的实例变量调用例子： [java] view plain copy JButton b1 = new JButton(&quot;button1&quot;); System.out.println(b1.getClass()); 输出： class javax.swing.JButton class属性当你要获得一个类的Class对象时（作函数参数的时候），你不能调用getClass方法，那你只能用类名.class来达到效果例子： [java] view plain copy System.out.println(JButton.class); 输出：class javax.swing.JButton getName方法：类型：public String getName()功能：以String形式返回次Class对象所表示的实体名称例子： [java] view plain copy JButton b1 = new JButton(&quot;button1&quot;); System.out.println(b1.getName()); 输出：javax.swing.JButton 可以发现用class属性和getClass返回的输出是一样的，用getName返回的比前面两种少了class和一个空格。","categories":[],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"《深入理解JVM》阅读笔记","slug":"深入理解JVM阅读笔记","date":"2017-06-17T02:05:54.000Z","updated":"2017-06-19T03:48:16.000Z","comments":true,"path":"2017/06/17/深入理解JVM阅读笔记/","link":"","permalink":"http://yoursite.com/2017/06/17/深入理解JVM阅读笔记/","excerpt":"","text":"将阅读周志明先生的《深入理解JVM》疑问与感悟再次做总结。什么是Native方法本地方法栈是存放native函数的，可是什么是native函数呢？百度之： 参考：http://blog.csdn.net/funneies/article/details/8949660 native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。 JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"Shiro权限框架整合总结与开源分享","slug":"shiro权限框架整合开源分享","date":"2017-06-12T09:52:54.000Z","updated":"2017-08-14T05:05:26.000Z","comments":true,"path":"2017/06/12/shiro权限框架整合开源分享/","link":"","permalink":"http://yoursite.com/2017/06/12/shiro权限框架整合开源分享/","excerpt":"2017年年初在供应链项目正式应用shiro权限框架，当时对一些问题做了一些记录。此次做全面总结。","text":"2017年年初在供应链项目正式应用shiro权限框架，当时对一些问题做了一些记录。此次做全面总结。shiro框架已经整合成单独一个服务，github地址：https://github.com/yuaman/shiro-service 添加favicon重定向问题（转）文件放在 static/common/images 路径下，页面 head 里加上 浏览器可以成功显示 favicon.ico，但是在第一次登陆成功后会自动重定向到 /favicon.ico 文件的路径。 网上的解决办法：基本大多数浏览器都会请求 favicon.ico 这个图标文件用来展示在浏览器的URL地址前面，而这个文件被shiro保护了。解决方法： 在 filterChainDefinitions 下配置 /favicon.ico 以匿名访问 /favicon.ico = anon可是我配置好 /static/common/images/favicon.ico = anon 后，还是会重定向。 多次测试之后发现anon配置的顺序会有影响。 Shiro验证URL时，URL匹配成功便不再继续匹配查找，所以要注意配置文件中的URL顺序，尤其在使用通配符时。故filterChainDefinitions的配置顺序为自上而下，以最上面的为准。 1. &lt;property name=&quot;filterChainDefinitions&quot;&gt; 2. &lt;value&gt; 3. /static/common/images/favicon.ico = anon 4. /resources/**=anon 5. /systemManage/resources/**=anon 6. /unauthorized = authc 7. /login = authc 8. /logout = logout 9. &lt;!--/authenticated = authc--&gt; 10. /** = user,sysUser 11. &lt;/value&gt; 12. &lt;/property&gt; 只是调整了 /static/common/images/favicon.ico = anon 的顺序。 过滤器 anon 表示可匿名使用，可以理解为匿名用户或游客，无需认证便可以访问的的文件。","categories":[],"tags":[{"name":"个人开源项目","slug":"个人开源项目","permalink":"http://yoursite.com/tags/个人开源项目/"}]},{"title":"电商项目物流接口集成总结与开源分享","slug":"电商项目物流接口集成总结与开源分享","date":"2017-06-11T12:20:54.000Z","updated":"2017-08-14T05:06:09.000Z","comments":true,"path":"2017/06/11/电商项目物流接口集成总结与开源分享/","link":"","permalink":"http://yoursite.com/2017/06/11/电商项目物流接口集成总结与开源分享/","excerpt":"迄今为止做了两个电商项目，在物流对接部分总结了一些东西，将可以通用的东西贴出来，供有需要的同学参考。可以少走很多弯路，避一些坑。 在做的过程中遇到很多坑，但是当时没有即时进行记录，只有这个调好了的最终版本。包括顺丰，圆通，EMS，德邦，申通五家物流公司，每家物流公司大致上需要調的接口有下物流订单，物流记录回传，打印物流电子面单，物流地址信息实时查询以及物流地址信息主动接收等接口。","text":"迄今为止做了两个电商项目，在物流对接部分总结了一些东西，将可以通用的东西贴出来，供有需要的同学参考。可以少走很多弯路，避一些坑。 在做的过程中遇到很多坑，但是当时没有即时进行记录，只有这个调好了的最终版本。包括顺丰，圆通，EMS，德邦，申通五家物流公司，每家物流公司大致上需要調的接口有下物流订单，物流记录回传，打印物流电子面单，物流地址信息实时查询以及物流地址信息主动接收等接口。 github物流对接服务开源地址：https://github.com/yuaman/logistics-service","categories":[],"tags":[{"name":"个人开源项目","slug":"个人开源项目","permalink":"http://yoursite.com/tags/个人开源项目/"}]},{"title":"mac下IntelliJ使用记录","slug":"mac下IntelliJ使用记录","date":"2017-06-07T03:17:54.000Z","updated":"2017-08-14T05:06:44.000Z","comments":true,"path":"2017/06/07/mac下IntelliJ使用记录/","link":"","permalink":"http://yoursite.com/2017/06/07/mac下IntelliJ使用记录/","excerpt":"遇坑总结","text":"遇坑总结不要用汉化包用了汉化包preferences就不好用了，字号完全无法更改，切换页面风格也会产生一半黑一半白的问题，jrebel也无法重启。无法，只能重装。 项目结构颜色问题重装问题也无法解决一半黑一半白的问题，最终发现是设置-颜色（file-color）中以前某个时候定义的，删掉就好了。 svn集成问题idea 自动集成svn，可是后来出了点问题。在提交与更新时总是弹出需要提交svn的认证，stackoverflow上有几个回答，mac下的情况更复杂，实在解决不了。改用cornerstone （mac下目前唯一能够被破解的SVN client）进行进行svn管理。cornerstone的自动识别被修改的文件功能很强大。附上该工具具体的版本管理使用说明：（http://www.cnblogs.com/fyongbetter/p/5404697.html） 快捷键设置最好先把keymap设置成“eclipse mac”的模式，这样的话我们的ctrl就变成command，举例来说ctrl+d删除一行就变成command+d，在此基础上设置其他快捷键。","categories":[],"tags":[{"name":"操作记录","slug":"操作记录","permalink":"http://yoursite.com/tags/操作记录/"}]},{"title":"读《罗马人物语-恺撒时代》","slug":"读《罗马人物语-恺撒时代》","date":"2017-06-04T14:54:57.000Z","updated":"2017-08-14T05:05:47.000Z","comments":true,"path":"2017/06/04/读《罗马人物语-恺撒时代》/","link":"","permalink":"http://yoursite.com/2017/06/04/读《罗马人物语-恺撒时代》/","excerpt":"这周末抽出时间看了盐野七生的恺撒战记，基本上是百度百科“恺撒”词条的详细版。或许是年龄大了，不再像以前读传记那么有代入感容易激动。","text":"这周末抽出时间看了盐野七生的恺撒战记，基本上是百度百科“恺撒”词条的详细版。或许是年龄大了，不再像以前读传记那么有代入感容易激动。 历史纪实性小说或许在专业人士看来，不严谨不入流，有的地方啰嗦。但我的体会是，历史纪实性小说能够让身处现代的人有更强的代入感，能够更深刻对历史上发生的情境感同身受，比一开始读专业的史书会更加给人以启发。当然，类似这种纪实性小说体裁作品通常篇幅很多，读完一遍基本差不多了。以后再读相关历史，最好还是找相应历史人物及事件的权威史书，简洁明了，更多感悟思考。类似孙皓晖的《大秦帝国》，记得一共是五百六十万字左右，14年初的时候先是在手机上看后来买书来看，看的昏天黑地，时不时泪流满面，有时间可以聊聊其中一些故事。其中固然有啰嗦以及根据可考真实历史发挥创作的地方，但更多是感动和震撼以及启发，可以说对我产生一定影响。这两年再没有那样的时候了。 鲁迅一有句诗“岂有豪情似旧时，花开花落两由之“，初读只觉被吸引，这两天体会颇深：当年无知者无畏，敢说敢拚敢闯，“尬点”极低，不在乎。如今经历过世事维艰后，实在难回复从前心境。 想起不久前一位女同事说我“你平时总是看起来很累，是不是早衰啊”，我无话，心里只有一入江湖岁月摧之感，可风云却是还不知道出自哪一辈。嬴政二十一岁早就立志要继往开来成就八百年没有过的奇功伟业；刘邦二十一岁估计还在家乡游手好闲；霍去病二十二岁北驱匈奴，燕然勒功；曹操二十岁时靠家里当上了首都的一个区公安局局长，壮志踌躇，要做大汉朝治世之名臣，一顿棒子打死蹇硕的叔叔，最终被迫回老家；李世民官二代 不说了；赵匡胤估计二十一岁也还是在江湖上游荡；朱重八可能刚刚离开寺庙，开始五年的乞讨流浪；蒋介石这时候是在上海滩炒股还是搞暗杀来着；太祖貌似是刚从北大图书馆回来或者是在长沙的图书馆看书。地球上有过一千亿人存在，也还将有一千亿人存在。我是其中一个。何去何从？随波逐流吗？ 大琐罗亚斯有过这么一句晦涩的话：来如流水昔逝如斯飘飘入世如水之不得不流不知何故来也不知何所终。 最近入了一套资治通鉴，一眼望过去就是四个字：沉闷枯燥。可这就是中国的历史，兴衰更替，帝王将相们的一言一行。想起太祖一句词“一篇读罢头飞雪，但记得斑斑点点，几行陈迹”，中国的事儿或许就都在这么一套书里，几十个百年来你方唱罢我登场，演来演去都是差不多的剧情，差不多的套路，差不多的人心。但是这些大片实际拍出来动作戏等具象的东西却都是花样翻新。太祖的意思或许是读完这套书，再结合斗争实际和现实人生境遇反复读，等到真读懂读透，或者一生也就差不多了，但书里的东西曾经那么研究，咋一想也想不太起来。 说是读恺撒，先摘录一段盐野七生的话吧： 凯撒这样的男人是拒绝对他人怀有怨恨感情的。因为怨恨是对于自己实力相当的或是比自己地位更高的人才有的绝对优势地位有着充分的自负。当然要拒绝怨恨，这种所谓下等人才有的情感。 忘了是西方哪个人说过：一切伟大的人物最伟大的是恺撒。个人的体会是恺撒是个善于表演的人，是一个有着深刻自我修养的表演艺术家。他在深刻务实的同时也在深刻的务虚，故能成其大。因为纯粹的善良和宽容即使是在日常生活中也是要受到中伤的，更何况是在政治场中。而庞培之所以失败，或许也是败在“务实”上走了极端。 关于恺撒的传记我之前买过逻辑思维出的版本，感觉有些繁琐没时间读。读了盐野七生的版本，仍旧是懵懵懂懂。一直以来我最大的疑问以及最感兴趣的地方在于：恺撒三十岁后正式从政，四十岁开始声名鹊起，打了许多年仗固然是胜多败少极大地满足了当时的人的虚荣心，可能在古罗马时代伟大的人物的确是不少，论战功庞培的战功不见得比恺撒差，论魅力奥古斯都一样有魅力并且比凯撒还要帅，论历史影响屋大维才是真正的建国者，而且屋大维一样的有三头政治，一样的起于不利，一样的沙场所向披靡，为什么独独凯撒被西方世界铭记得最深刻？他身上到底有些什么东西让人着迷？可能不是西方人很难搞懂。也和我国相关历史研究和译作不多有关系。我最近对西方历史比较感兴趣，知己知彼百战不殆，未来是中国的时代，东西方兴衰交替的变革时代，应该对洋人的历史和文化和思维模式以及世界观、审美等有所了解。就书中了解到的情况看，那时候不管是东方的秦国还是西方的罗马，都是有着深刻的建立辉煌所必需的精神和物质条件的，换句话说，值得去了解以及思考以及学习。 因为是此书用kindle看的，时间紧张摘抄不易，以后有机会争取把精华做分享。盐野的文字还是比较浅显，中国人爱作小聪明，也看不惯日本人直白诚恳的表露，但就大多数人在基本历史常识的普及上，还是值得一览。 上文中有对历史人物的妄评，用《邺中歌》中此句作结： 古人做事无巨细，寂寞豪华皆有意。书生轻议冢中人，冢中笑尔书生气！ ————出自《三国演义》第七十八回 曹操死的那一回 得空陪母亲动物园一游，附图一张。其实是这几年来第一次和她一起出去玩，再往前依稀是我十岁左右在旅顺全家人经常一起出去玩。自从我几年前做出抉择要走自己的路，她心里愁苦不解，我时刻想着自己的事，父亲工作，我们都无心这些了。来大连这些年竟从未去过森林动物园看卡，近来原想的是自己漂泊不定，趁在的时候抽空走一走看一看，后来母亲说想要一起去，想请我去玩。我心里其实很欢喜，很期待，是那种久违的欢喜和期待，几年来未曾有。我知道，她是希望我心情好一些，放松放松，放下一些东西，其实自己未必想去。我则想着带着她一起，世事难料，免得将来有遗憾，眼下彼此能互相弥补一些是一些。用一句话来形容或许会让人很奇怪匪夷所思：渡尽劫波兄弟在，相逢一笑泯恩仇。你觉奇怪，我也觉奇怪，但心思确实可以用这句话来形容。 人间事千头万绪，苦思不得解。絮语惹人烦。 不说了，面已凉。 背影寥落的老虎在嘘嘘","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"mac下hexo搭建相关记录","slug":"mac下hexo搭建操作记录","date":"2017-05-31T13:08:57.000Z","updated":"2017-08-14T04:54:13.000Z","comments":true,"path":"2017/05/31/mac下hexo搭建操作记录/","link":"","permalink":"http://yoursite.com/2017/05/31/mac下hexo搭建操作记录/","excerpt":"吃水不忘挖井人，今天把hexo在mac下的搭建和部署说一下。hexo是个挺有意思的东西，但是，因为版本和配置细节等问题，这两天遇坑无数。重装了四五遍。到今晚终于给整差不多了。着重把遇到的问题给说一下。","text":"吃水不忘挖井人，今天把hexo在mac下的搭建和部署说一下。hexo是个挺有意思的东西，但是，因为版本和配置细节等问题，这两天遇坑无数。重装了四五遍。到今晚终于给整差不多了。着重把遇到的问题给说一下。 No1:nvm问题刚开始要注意使用nvm来控制node版本并且注意node版本最好是6.2以上（我因为版本低重装了一遍） No.2:部署成功github访问报404解决：github有缓存，等一会儿或者一晚上，就好了 No.3:注意_config.yml的配置一定要在冒号之后留出空格，否则会报出各种奇葩问题。 _config.yml中都要用半角来输入，要注意比较常见的“／”，因为此符半角全角分不太出来。 No.4markdown编辑器我采用马克飞象先命令行新建md文件，然后利用xcode打开，在马克飞象中编辑后copy到其中，或terminal中利用vim打开，编辑后copy到其中。 No.5我所采用的主题：https://github.com/litten/hexo-theme-yilia No.6使用yilia主题遇到的一些问题解决办法1 我们发布的文章是在主页显示的时候全部显示，那样很长很难看，想要部分展示的效果。 使用”&lt;! – more – &gt;”标签来隐藏其下面的内容~ 实在有坑填不了，换个目录重装，也比在那里纠结快，每重装一次都会比之前快 过程中遇坑无数，我着急解决没有记录下来现在也想不太起来了。善用谷歌和百度，会有意想不到的收获。最初我以为hexo冷门在网络上不会有什么记录没想到一大堆。 图片引用用markdown语法不好用，“”;最终只是用了html标签 域名问题在godaddy上买到了符合我名字的yutinglin.cn,也不知道会不会被封 Markdown编辑器用了十几天马克飞象之后还是转到macdown了，马克飞象需要付费但是因为小众没有破解。 DNS解析利用DNSPOD进行解析，1.在yourname.github.io的根目录下添加CNAME具体就是在Hexo目录里的source文件下添加一个名为CNAME的文件，注意这个文件是没有后缀的，千万不要设置成.txt文本文件，文件的内容就是域名，格式如： niujiajun.com 2.在DNSPOD管理页面点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是whitescholars.github.io。 评论系统采用网易云跟帖，发现各家评论都很恶心，都需要用户登陆才能评论，完全不考虑用户需求和体验。发现即使是程序员DD的一片最新文章用的畅言评论系统也只有两个评论，这样的话如何起到和大家沟通的作用呢？ 需要注意的地方1.标题设置“###”之后需要空格才能显示出来","categories":[],"tags":[{"name":"操作记录","slug":"操作记录","permalink":"http://yoursite.com/tags/操作记录/"}]},{"title":"缘起","slug":"缘起","date":"2017-05-30T02:05:54.000Z","updated":"2017-06-17T01:57:45.000Z","comments":true,"path":"2017/05/30/缘起/","link":"","permalink":"http://yoursite.com/2017/05/30/缘起/","excerpt":"端午之前读了一篇文章，讲了从写博客对一个程序员的进步的好处。遂决定开始动手，完成半年之前未竟的搭建hexo的事业。","text":"端午之前读了一篇文章，讲了从写博客对一个程序员的进步的好处。遂决定开始动手，完成半年之前未竟的搭建hexo的事业。首先从工作的角度来讲，这么做有相当的必要性，不待赘言。其次我和博客也很早就有一些渊源。 从QQ空间时代开始，便喜欢捣鼓。那时候虽然小，写的东西倒也能多少得到同学们和老师们的一些品评。12年的时候在旅顺海滨独自一人的时候，也曾写过几首打油诗和不入流的文章放在新浪轻博客和网易博客上。后来生活所迫，无心维护，这两个产品也没落不为人所知了。12年的时候，我十五岁，那时候阿里巴巴刚刚搞了双十一，BAT的名头还不是那么为众人 所知，还没有内容创业这回事。转眼就是四年。 四年光阴，来如流水，希逝如斯，不必赘述。到今天若说有什么感悟，就是四个字：世事无常。 算起来进入IT行业也有将近两年多了，虚度时多，事业成就一点没有，工作成果不值一提，能力依旧一般。近来得一前辈指点，虽然AI的大潮也想尽力赶上，但眼下还是搞好基础,主要是Java的基础。 过去主要是利用印象笔记偶尔记下日记和笔记以及技术相关的文章和bug总结。以此为契机 ，精进课业，把学习的心得和读书的体会以及技术上的一些操作记录放在这里。尽管资质愚钝，想必也能有所进步。如果能够通过这个小平台给朋友提供一些参考，那是最好不过。 hexo是个不错的东西，在mac上搭建有一些坑，明后天将记录一下与此相关的一些东西。","categories":[],"tags":[{"name":"杂感","slug":"杂感","permalink":"http://yoursite.com/tags/杂感/"}]},{"title":"Redis集群部署与集成总结","slug":"Redis集群部署与集成总结","date":"2016-12-19T02:05:54.000Z","updated":"2017-06-11T12:45:13.000Z","comments":true,"path":"2016/12/19/Redis集群部署与集成总结/","link":"","permalink":"http://yoursite.com/2016/12/19/Redis集群部署与集成总结/","excerpt":"16年末开始了解redis并加入当时所做电商项目中。遇到过一些问题，于当时做了记录。","text":"16年末开始了解redis并加入当时所做电商项目中。遇到过一些问题，于当时做了记录。 jedis客户端调用redis集群异常总结在虚拟机以及远程服务器同时测试节点全部开启，集群check命令显示主从均正常 于控制台开启某一节点的cli，set测试，正常。 在类文件中连接集群某一结点，调用，报错如下no reachable node in cluster 于application.xml中配置启动tomcat抱如下错：org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘JedisCluster’ defined in class path resource [conf/applicationContext.xml]: Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities) 最终解决：发现三个错误：连接池配置错误，集群不能使用jedispooljar包冲突，spring session与jedis2.7冲突，但集群又必须使用2.7，以前使用单机版redisredis集群服务器防火墙设置问题，导致no rechable nodes异常 后来又报了一个异常：too many nodes重启redis服务器还有增大连接数","categories":[],"tags":[{"name":"操作记录","slug":"操作记录","permalink":"http://yoursite.com/tags/操作记录/"}]}]}